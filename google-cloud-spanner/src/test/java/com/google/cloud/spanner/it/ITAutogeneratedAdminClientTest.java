/*
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.cloud.spanner.it;

import static com.google.cloud.spanner.testing.EmulatorSpannerHelper.isUsingEmulator;
import static com.google.common.truth.Truth.assertThat;
import static org.junit.Assert.*;
import static org.junit.Assume.assumeFalse;

import com.google.api.gax.rpc.PermissionDeniedException;
import com.google.cloud.spanner.DatabaseClient;
import com.google.cloud.spanner.DatabaseId;
import com.google.cloud.spanner.ErrorCode;
import com.google.cloud.spanner.InstanceId;
import com.google.cloud.spanner.IntegrationTestEnv;
import com.google.cloud.spanner.ParallelIntegrationTest;
import com.google.cloud.spanner.ResultSet;
import com.google.cloud.spanner.Spanner;
import com.google.cloud.spanner.SpannerException;
import com.google.cloud.spanner.SpannerOptions;
import com.google.cloud.spanner.Statement;
import com.google.cloud.spanner.admin.database.v1.DatabaseAdminClient;
import com.google.cloud.spanner.admin.instance.v1.InstanceAdminClient;
import com.google.cloud.spanner.testing.RemoteSpannerHelper;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Iterators;
import com.google.spanner.admin.database.v1.CreateDatabaseRequest;
import com.google.spanner.admin.database.v1.Database;
import com.google.spanner.admin.database.v1.DatabaseDialect;
import com.google.spanner.admin.database.v1.DatabaseName;
import com.google.spanner.admin.database.v1.InstanceName;
import com.google.spanner.admin.instance.v1.InstanceConfig;
import com.google.spanner.admin.instance.v1.ProjectName;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.ClassRule;
import org.junit.Test;
import org.junit.experimental.categories.Category;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameter;
import org.junit.runners.Parameterized.Parameters;

/**
 * Integration tests for testing the auto-generated database admin {@link
 * com.google.cloud.spanner.admin.database.v1.DatabaseAdminClient} and instance admin clients {@link
 * com.google.cloud.spanner.admin.instance.v1.InstanceAdminClient}
 */
@Category(ParallelIntegrationTest.class)
@RunWith(Parameterized.class)
public class ITAutogeneratedAdminClientTest {

  @ClassRule public static IntegrationTestEnv env = new IntegrationTestEnv();
  private static DatabaseAdminClient dbAdminClient;

  private static InstanceAdminClient instanceAdminClient;
  private static RemoteSpannerHelper testHelper;

  private static List<DatabaseName> databasesToDrop;

  @Parameter public DatabaseDialect dialect;

  @Parameters(name = "Dialect = {0}")
  public static List<DatabaseDialect> data() {
    return ImmutableList.of(DatabaseDialect.GOOGLE_STANDARD_SQL, DatabaseDialect.POSTGRESQL);
  }

  @BeforeClass
  public static void setUp() {
    assumeFalse("Emulator does not support database roles", isUsingEmulator());
    testHelper = env.getTestHelper();
    dbAdminClient = testHelper.getClient().createDatabaseAdminClient();
    instanceAdminClient = testHelper.getClient().createInstanceAdminClient();
    databasesToDrop = new ArrayList<>();
  }

  @AfterClass
  public static void cleanup() throws Exception {
    if (databasesToDrop != null) {
      for (DatabaseName databaseName : databasesToDrop) {
        try {
          dbAdminClient.dropDatabase(databaseName);
        } catch (Exception e) {
          System.err.println(
              "Failed to drop database " + databaseName + ", skipping...: " + e.getMessage());
        }
      }
    }
  }

  @Test
  public void grantAndRevokeDatabaseRolePermissions() throws Exception {
    // Create database with table and role permission.
    final String dbRoleParent = "parent";
    final String databaseId = testHelper.getUniqueDatabaseId();
    final InstanceId instanceId = testHelper.getInstanceId();

    final String createTableT = getCreateTableStatement();
    final String createRoleParent = String.format("CREATE ROLE %s", dbRoleParent);
    final String grantSelectOnTableToParent =
        dialect == DatabaseDialect.POSTGRESQL
            ? String.format("GRANT SELECT ON TABLE T TO %s", dbRoleParent)
            : String.format("GRANT SELECT ON TABLE T TO ROLE %s", dbRoleParent);
    final Database createdDatabase =
        createAndUpdateDatabase(
            testHelper.getOptions().getProjectId(),
            instanceId,
            databaseId,
            ImmutableList.of(createTableT, createRoleParent, grantSelectOnTableToParent));

    // Connect to db with dbRoleParent.
    SpannerOptions options =
        testHelper.getOptions().toBuilder().setDatabaseRole(dbRoleParent).build();

    Spanner spanner = options.getService();
    DatabaseId id = DatabaseId.of(createdDatabase.getName());
    DatabaseClient dbClient = spanner.getDatabaseClient(id);

    // Test SELECT permissions to role dbRoleParent on table T.
    // Query using dbRoleParent should return result.
    try (ResultSet rs =
        dbClient.singleUse().executeQuery(Statement.of("SELECT COUNT(*) as cnt FROM T"))) {
      assertTrue(rs.next());
      assertEquals(dbClient.getDatabaseRole(), dbRoleParent);
    } catch (PermissionDeniedException e) {
      // This is not expected
      fail("Got PermissionDeniedException when it should not have occurred.");
    }

    // Revoke select Permission for dbRoleParent.
    final String revokeSelectOnTableFromParent =
        dialect == DatabaseDialect.POSTGRESQL
            ? String.format("REVOKE SELECT ON TABLE T FROM %s", dbRoleParent)
            : String.format("REVOKE SELECT ON TABLE T FROM ROLE %s", dbRoleParent);

    dbAdminClient
        .updateDatabaseDdlAsync(
            DatabaseName.of(options.getProjectId(), instanceId.getInstance(), databaseId),
            ImmutableList.of(revokeSelectOnTableFromParent))
        .get(5, TimeUnit.MINUTES);

    // Test SELECT permissions to role dbRoleParent on table T.
    // Query using dbRoleParent should return PermissionDeniedException.
    try (ResultSet rs =
        dbClient.singleUse().executeQuery(Statement.of("SELECT COUNT(*) as cnt FROM T"))) {
      SpannerException e = assertThrows(SpannerException.class, () -> rs.next());
      assertThat(e.getErrorCode()).isEqualTo(ErrorCode.PERMISSION_DENIED);
      assertThat(e.getMessage()).contains(dbRoleParent);
    }
    // Drop role and table.
    final String dropTableT = "DROP TABLE T";
    final String dropRoleParent = String.format("DROP ROLE %s", dbRoleParent);
    dbAdminClient
        .updateDatabaseDdlAsync(
            DatabaseName.of(options.getProjectId(), instanceId.getInstance(), databaseId),
            ImmutableList.of(dropTableT, dropRoleParent))
        .get(5, TimeUnit.MINUTES);
    databasesToDrop.add(DatabaseName.parse(createdDatabase.getName()));
  }

  @Test
  public void roleWithNoPermissions() throws Exception {
    final String dbRoleOrphan = testHelper.getUniqueDatabaseRole();
    final String databaseId = testHelper.getUniqueDatabaseId();
    final InstanceId instanceId = testHelper.getInstanceId();

    final String createTableT = getCreateTableStatement();
    final String createRoleOrphan = String.format("CREATE ROLE %s", dbRoleOrphan);

    final Database createdDatabase =
        createAndUpdateDatabase(
            testHelper.getOptions().getProjectId(),
            instanceId,
            databaseId,
            ImmutableList.of(createTableT, createRoleOrphan));

    // Connect to db with dbRoleOrphan
    SpannerOptions options =
        testHelper.getOptions().toBuilder().setDatabaseRole(dbRoleOrphan).build();

    Spanner spanner = options.getService();
    DatabaseId id = DatabaseId.of(createdDatabase.getName());
    DatabaseClient dbClient = spanner.getDatabaseClient(id);

    // Test SELECT permissions to role dbRoleOrphan on table T.
    // Query using dbRoleOrphan should return PermissionDeniedException.
    try (ResultSet rs =
        dbClient.singleUse().executeQuery(Statement.of("SELECT COUNT(*) as cnt FROM T"))) {
      SpannerException e = assertThrows(SpannerException.class, () -> rs.next());
      assertThat(e.getErrorCode()).isEqualTo(ErrorCode.PERMISSION_DENIED);
      assertThat(e.getMessage()).contains(dbRoleOrphan);
    }
    // Drop role and table.
    final String dropTableT = "DROP TABLE T";
    final String dropRoleParent = String.format("DROP ROLE %s", dbRoleOrphan);
    dbAdminClient
        .updateDatabaseDdlAsync(
            DatabaseName.of(options.getProjectId(), instanceId.getInstance(), databaseId),
            ImmutableList.of(dropTableT, dropRoleParent))
        .get(5, TimeUnit.MINUTES);

    databasesToDrop.add(DatabaseName.parse(createdDatabase.getName()));
  }

  @Test
  public void instanceConfigOperations() {
    List<InstanceConfig> configs = new ArrayList<>();
    Iterators.addAll(
        configs,
        instanceAdminClient
            .listInstanceConfigs(ProjectName.of(testHelper.getOptions().getProjectId()))
            .iterateAll()
            .iterator());
    assertThat(configs.isEmpty()).isFalse();
    InstanceConfig config = instanceAdminClient.getInstanceConfig(configs.get(0).getName());
    assertThat(config.getName()).isEqualTo(configs.get(0).getName());
  }

  private Database createAndUpdateDatabase(
      String projectId,
      final InstanceId instanceId,
      final String databaseId,
      final List<String> statements)
      throws Exception {
    if (dialect == DatabaseDialect.POSTGRESQL) {
      // DDL statements other than <CREATE DATABASE> are not allowed in database creation request
      // for PostgreSQL-enabled databases.
      CreateDatabaseRequest createDatabaseRequest =
          CreateDatabaseRequest.newBuilder()
              .setParent(InstanceName.of(projectId, instanceId.getInstance()).toString())
              .setCreateStatement(getCreateDatabaseStatement(databaseId, dialect))
              .setDatabaseDialect(dialect)
              .build();
      Database database =
          dbAdminClient.createDatabaseAsync(createDatabaseRequest).get(10, TimeUnit.MINUTES);
      dbAdminClient.updateDatabaseDdlAsync(database.getName(), statements).get(5, TimeUnit.MINUTES);
      return database;
    } else {
      CreateDatabaseRequest createDatabaseRequest =
          CreateDatabaseRequest.newBuilder()
              .setParent(InstanceName.of(projectId, instanceId.getInstance()).toString())
              .setCreateStatement(getCreateDatabaseStatement(databaseId, dialect))
              .setDatabaseDialect(dialect)
              .addAllExtraStatements(statements)
              .build();
      return dbAdminClient.createDatabaseAsync(createDatabaseRequest).get(10, TimeUnit.MINUTES);
    }
  }

  private String getCreateTableStatement() {
    if (dialect == DatabaseDialect.POSTGRESQL) {
      return "CREATE TABLE T (" + "  \"K\"    VARCHAR PRIMARY KEY" + ")";
    } else {
      return "CREATE TABLE T (" + "  K    STRING(MAX)" + ") PRIMARY KEY (K)";
    }
  }

  static String getCreateDatabaseStatement(
      final String databaseName, final DatabaseDialect dialect) {
    if (dialect == DatabaseDialect.GOOGLE_STANDARD_SQL) {
      return "CREATE DATABASE `" + databaseName + "`";
    } else {
      return "CREATE DATABASE \"" + databaseName + "\"";
    }
  }
}
