/*
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.cloud.spanner.connection;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;

import com.google.cloud.spanner.Dialect;
import com.google.cloud.spanner.ErrorCode;
import com.google.cloud.spanner.SpannerExceptionFactory;
import com.google.cloud.spanner.Statement;
import com.google.cloud.spanner.connection.AbstractStatementParser.ParsedStatement;
import com.google.cloud.spanner.connection.StatementResult.ClientSideStatementType;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.nio.charset.StandardCharsets;
import java.time.Duration;
import java.time.temporal.ChronoUnit;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.junit.AfterClass;
import org.junit.Test;

/**
 * Test that runs a pre-generated sql script for {@link ClientSideStatement}s. The sql script can be
 * generated by running <code>
 * mvn -Ddo_log_statements=true exec:java -Dexec.mainClass=com.google.cloud.spanner.connection.SqlTestScriptsGenerator -Dexec.classpathScope="test"
 * </code> It is only necessary to generate a new test script if a new {@link ClientSideStatement}
 * has been added, or the behavior of an existing {@link ClientSideStatement} has changed.
 *
 * <p>This class does not need to be implemented for the client libraries of other programming
 * languages. All test cases are covered by the sql file ClientSideStatementsTest.sql.
 */
public class ClientSideStatementsTest extends AbstractSqlScriptTest {

  private static String getScriptFile(Dialect dialect) {
    switch (dialect) {
      case GOOGLE_STANDARD_SQL:
        return "ClientSideStatementsTest.sql";
      case POSTGRESQL:
        return "postgresql/ClientSideStatementsTest.sql";
      default:
        throw SpannerExceptionFactory.newSpannerException(
            ErrorCode.INVALID_ARGUMENT, "Unknown or unsupported dialect: " + dialect);
    }
  }

  @Test
  public void testExecuteClientSideStatementsScript() throws Exception {
    SqlScriptVerifier verifier = new SqlScriptVerifier(new TestConnectionProvider(dialect));
    verifier.verifyStatementsInFile(getScriptFile(dialect), getClass(), true);
  }

  @Test
  public void testClientSideStatementType() {
    AbstractStatementParser parser = AbstractStatementParser.getInstance(dialect);

    assertEquals(
        ClientSideStatementType.BEGIN,
        parser.parse(Statement.of("BEGIN TRANSACTION")).getClientSideStatementType());
    assertEquals(
        ClientSideStatementType.COMMIT,
        parser.parse(Statement.of("COMMIT TRANSACTION")).getClientSideStatementType());
    assertEquals(
        ClientSideStatementType.ROLLBACK,
        parser.parse(Statement.of("ROLLBACK TRANSACTION")).getClientSideStatementType());
    if (dialect == Dialect.POSTGRESQL) {
      assertEquals(
          ClientSideStatementType.ROLLBACK,
          parser.parse(Statement.of("ABORT")).getClientSideStatementType());
      assertEquals(
          ClientSideStatementType.ROLLBACK,
          parser.parse(Statement.of("ABORT TRANSACTION")).getClientSideStatementType());
      assertEquals(
          ClientSideStatementType.ROLLBACK,
          parser.parse(Statement.of("ABORT WORK")).getClientSideStatementType());
      assertEquals(
          ClientSideStatementType.ROLLBACK,
          parser
              .parse(Statement.of("ABORT TRANSACTION and no chain"))
              .getClientSideStatementType());
    }

    for (ClientSideStatementImpl statement : parser.getClientSideStatements()) {
      assertNotNull(
          statement.toString() + " misses a statement type", statement.getStatementType());
    }
  }

  private static class DurationTestData {
    final String sql;
    final Duration expected;

    DurationTestData(String sql, Duration expected) {
      this.sql = sql;
      this.expected = expected;
    }
  }

  @Test
  public void testSetStatementTimeout() {
    AbstractStatementParser parser = AbstractStatementParser.getInstance(dialect);

    String resetValue = dialect == Dialect.POSTGRESQL ? "default" : "null";
    for (DurationTestData data :
        new DurationTestData[] {
          new DurationTestData("set statement_timeout=10", Duration.ofMillis(10)),
          new DurationTestData("set statement_timeout = 10", Duration.ofMillis(10)),
          new DurationTestData("set statement_timeout = 10 ", Duration.ofMillis(10)),
          new DurationTestData("set statement_timeout='10ms'", Duration.ofMillis(10)),
          new DurationTestData("set statement_timeout = '10ms'", Duration.ofMillis(10)),
          new DurationTestData("set statement_timeout = '10ms' ", Duration.ofMillis(10)),
          new DurationTestData("set statement_timeout='10ns'", Duration.ofNanos(10)),
          new DurationTestData("set statement_timeout = '10ns'", Duration.ofNanos(10)),
          new DurationTestData("set statement_timeout = '10ns' ", Duration.ofNanos(10)),
          new DurationTestData("set statement_timeout='10us'", Duration.of(10, ChronoUnit.MICROS)),
          new DurationTestData(
              "set statement_timeout = '10us'", Duration.of(10, ChronoUnit.MICROS)),
          new DurationTestData(
              "set statement_timeout = '10us' ", Duration.of(10, ChronoUnit.MICROS)),
          new DurationTestData("set statement_timeout='10s'", Duration.ofSeconds(10)),
          new DurationTestData("set statement_timeout = '10s'", Duration.ofSeconds(10)),
          new DurationTestData("set statement_timeout = '10s' ", Duration.ofSeconds(10)),
          new DurationTestData("set statement_timeout=" + resetValue, Duration.ZERO),
          new DurationTestData("set statement_timeout = " + resetValue, Duration.ZERO),
          new DurationTestData("set statement_timeout = " + resetValue + " ", Duration.ZERO),
        }) {
      ConnectionStatementExecutor executor = mock(ConnectionStatementExecutor.class);
      ParsedStatement statement = parser.parse(Statement.of(data.sql));
      assertEquals(
          ClientSideStatementType.SET_STATEMENT_TIMEOUT, statement.getClientSideStatementType());
      statement.getClientSideStatement().execute(executor, statement);
      verify(executor).statementSetStatementTimeout(data.expected);
    }
  }

  @Test
  public void testSetMaxCommitDelay() {
    AbstractStatementParser parser = AbstractStatementParser.getInstance(dialect);

    String prefix = dialect == Dialect.POSTGRESQL ? "spanner." : "";
    for (DurationTestData data :
        new DurationTestData[] {
          new DurationTestData("set " + prefix + "max_commit_delay=10", Duration.ofMillis(10)),
          new DurationTestData("set " + prefix + "max_commit_delay = 10", Duration.ofMillis(10)),
          new DurationTestData("set " + prefix + "max_commit_delay = 10 ", Duration.ofMillis(10)),
          new DurationTestData("set " + prefix + "max_commit_delay='10ms'", Duration.ofMillis(10)),
          new DurationTestData(
              "set " + prefix + "max_commit_delay = '10ms'", Duration.ofMillis(10)),
          new DurationTestData(
              "set " + prefix + "max_commit_delay = '10ms' ", Duration.ofMillis(10)),
          new DurationTestData("set " + prefix + "max_commit_delay='10ns'", Duration.ofNanos(10)),
          new DurationTestData("set " + prefix + "max_commit_delay = '10ns'", Duration.ofNanos(10)),
          new DurationTestData(
              "set " + prefix + "max_commit_delay = '10ns' ", Duration.ofNanos(10)),
          new DurationTestData(
              "set " + prefix + "max_commit_delay='10us'", Duration.of(10, ChronoUnit.MICROS)),
          new DurationTestData(
              "set " + prefix + "max_commit_delay = '10us'", Duration.of(10, ChronoUnit.MICROS)),
          new DurationTestData(
              "set " + prefix + "max_commit_delay = '10us' ", Duration.of(10, ChronoUnit.MICROS)),
          new DurationTestData("set " + prefix + "max_commit_delay='10s'", Duration.ofSeconds(10)),
          new DurationTestData(
              "set " + prefix + "max_commit_delay = '10s'", Duration.ofSeconds(10)),
          new DurationTestData(
              "set " + prefix + "max_commit_delay = '10s' ", Duration.ofSeconds(10)),
          new DurationTestData("set " + prefix + "max_commit_delay=null", Duration.ZERO),
          new DurationTestData("set " + prefix + "max_commit_delay = null", Duration.ZERO),
          new DurationTestData("set " + prefix + "max_commit_delay = null ", Duration.ZERO),
        }) {
      ConnectionStatementExecutor executor = mock(ConnectionStatementExecutor.class);
      ParsedStatement statement = parser.parse(Statement.of(data.sql));
      assertEquals(
          ClientSideStatementType.SET_MAX_COMMIT_DELAY, statement.getClientSideStatementType());
      statement.getClientSideStatement().execute(executor, statement);
      verify(executor).statementSetMaxCommitDelay(data.expected);
    }
  }

  private static PrintWriter writer;

  /** Generates the test script file */
  static void generateTestScript(Dialect dialect) throws Exception {
    AbstractStatementParser parser = AbstractStatementParser.getInstance(dialect);
    try {
      openLog(dialect);
      ClientSideStatements statements = ClientSideStatements.getInstance(dialect);
      for (ClientSideStatementImpl statement : statements.getCompiledStatements()) {
        generateTestStatements(parser, statement);
      }
    } finally {
      closeLog();
    }
  }

  /** Writes the prerequisite statements + the given sql statement to a script file */
  private static void log(List<String> pre, String sql) {
    writeLog("NEW_CONNECTION");
    for (String prerequisite : pre) {
      writeLog(prerequisite);
    }
    writeLog(sql);
  }

  /**
   * Writes the prerequisite statements + the given sql statement to a script file preceded by
   * an @EXPECT EXCEPTION error statement
   */
  private static void log(List<String> pre, String statement, ErrorCode error) {
    log(pre, "@EXPECT EXCEPTION " + error.name() + "\n" + statement);
  }

  /** Writes the actual statement to the script file */
  private static void writeLog(String statement) {
    writer.println(statement + ";");
  }

  private static void openLog(Dialect dialect) {
    try {
      writer =
          new PrintWriter(
              new OutputStreamWriter(
                  new FileOutputStream(
                      "src/test/resources/com/google/cloud/spanner/connection/"
                          + getScriptFile(dialect),
                      false),
                  StandardCharsets.UTF_8),
              true);
    } catch (IOException e) {
      throw new RuntimeException(e);
    }
  }

  @AfterClass
  public static void closeLog() {
    if (writer != null) {
      writer.close();
    }
  }

  /** Generates test statements for all {@link ClientSideStatement}s */
  private static void generateTestStatements(
      AbstractStatementParser parser, ClientSideStatementImpl statement) {
    for (String sql : statement.getExampleStatements()) {
      log(statement.getExamplePrerequisiteStatements(), sql);
      if (statement.getStatementType() != ClientSideStatementType.RUN_PARTITION
          && statement.getStatementType() != ClientSideStatementType.SET_DIRECTED_READ) {
        // Partition ids are case-sensitive.
        // DirectedReadOptions are case-sensitive.
        log(statement.getExamplePrerequisiteStatements(), upper(sql));
        log(statement.getExamplePrerequisiteStatements(), lower(sql));
      }
      log(statement.getExamplePrerequisiteStatements(), withLeadingSpaces(sql));
      log(statement.getExamplePrerequisiteStatements(), withLeadingTabs(sql));
      log(statement.getExamplePrerequisiteStatements(), withLeadingLinefeeds(sql));
      log(statement.getExamplePrerequisiteStatements(), withTrailingSpaces(sql));
      log(statement.getExamplePrerequisiteStatements(), withTrailingTabs(sql));
      log(statement.getExamplePrerequisiteStatements(), withTrailingLinefeeds(sql));
      log(statement.getExamplePrerequisiteStatements(), withSpaces(sql));
      log(statement.getExamplePrerequisiteStatements(), withTabs(sql));
      log(statement.getExamplePrerequisiteStatements(), withLinefeeds(sql));

      log(
          statement.getExamplePrerequisiteStatements(),
          withInvalidPrefix(sql),
          ErrorCode.INVALID_ARGUMENT);

      boolean anySuffixAllowed =
          statement.getStatementType() == ClientSideStatementType.PARTITION
              || statement.getStatementType() == ClientSideStatementType.RUN_PARTITIONED_QUERY;
      if (anySuffixAllowed) {
        log(statement.getExamplePrerequisiteStatements(), withInvalidSuffix(sql));
      } else {
        log(
            statement.getExamplePrerequisiteStatements(),
            withInvalidSuffix(sql),
            parser.isQuery(withInvalidSuffix(sql))
                ? ErrorCode.UNIMPLEMENTED
                : ErrorCode.INVALID_ARGUMENT);
      }

      final String[] replacements = {
        "%", "_", "&", "$", "@", "!", "*", "(", ")", "-", "+", "-#", "/", "\\", "?", "-/", "/#",
        "/-"
      };
      for (String replacement : replacements) {
        log(
            statement.getExamplePrerequisiteStatements(),
            withPrefix(replacement, sql),
            ErrorCode.INVALID_ARGUMENT);
        if (anySuffixAllowed) {
          log(statement.getExamplePrerequisiteStatements(), withSuffix(replacement, sql));
        } else {
          log(
              statement.getExamplePrerequisiteStatements(),
              withSuffix(replacement, sql),
              parser.isQuery(withSuffix(replacement, sql))
                  ? ErrorCode.UNIMPLEMENTED
                  : ErrorCode.INVALID_ARGUMENT);
          log(
              statement.getExamplePrerequisiteStatements(),
              replaceLastSpaceWith(replacement, sql),
              parser.isQuery(replaceLastSpaceWith(replacement, sql))
                  ? ErrorCode.UNIMPLEMENTED
                  : ErrorCode.INVALID_ARGUMENT);
        }
      }
    }
  }

  private static String upper(String statement) {
    return statement.toUpperCase();
  }

  private static String lower(String statement) {
    return statement.toLowerCase();
  }

  private static String withLeadingSpaces(String statement) {
    return "   " + statement;
  }

  private static String withLeadingTabs(String statement) {
    return "\t\t\t" + statement;
  }

  private static String withLeadingLinefeeds(String statement) {
    return "\n\n\n" + statement;
  }

  private static String withTrailingSpaces(String statement) {
    return statement + "  ";
  }

  private static String withTrailingTabs(String statement) {
    return statement + "\t\t";
  }

  private static String withTrailingLinefeeds(String statement) {
    return statement + "\n\n";
  }

  private static String withSpaces(String statement) {
    return statement.replaceAll(" ", "   ");
  }

  private static String withTabs(String statement) {
    return statement.replaceAll(" ", "\t");
  }

  private static String withLinefeeds(String statement) {
    // Do not replace spaces inside quotes
    Matcher matcher = Pattern.compile("(.*)('.*')").matcher(statement);
    if (matcher.matches()) {
      return matcher.group(1).replaceAll(" ", "\n") + matcher.group(2);
    }
    return statement.replaceAll(" ", "\n");
  }

  private static String withInvalidPrefix(String statement) {
    return "foo " + statement;
  }

  private static String withInvalidSuffix(String statement) {
    return statement + " bar";
  }

  private static String withPrefix(String prefix, String statement) {
    return prefix + statement;
  }

  private static String withSuffix(String suffix, String statement) {
    return statement + suffix;
  }

  private static String replaceLastSpaceWith(String replacement, String statement) {
    if (statement.lastIndexOf(' ') > -1) {
      return statement.substring(0, statement.lastIndexOf(' '))
          + replacement
          + statement.substring(statement.lastIndexOf(' ') + 1);
    }
    return statement + replacement;
  }
}
