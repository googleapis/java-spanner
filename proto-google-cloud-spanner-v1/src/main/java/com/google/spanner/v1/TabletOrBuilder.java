/*
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/spanner/v1/location.proto

// Protobuf Java Version: 3.25.7
package com.google.spanner.v1;

public interface TabletOrBuilder
    extends
    // @@protoc_insertion_point(interface_extends:google.spanner.v1.Tablet)
    com.google.protobuf.MessageOrBuilder {

  /**
   *
   *
   * <pre>
   * The UID of the tablet, unique within the database. Matches the
   * `tablet_uids` and `leader_tablet_uid` fields in `Group`.
   * </pre>
   *
   * <code>uint64 tablet_uid = 1;</code>
   *
   * @return The tabletUid.
   */
  long getTabletUid();

  /**
   *
   *
   * <pre>
   * The address of the server that is serving this tablet -- either an IP
   * address or DNS hostname and a port number.
   * </pre>
   *
   * <code>string server_address = 2;</code>
   *
   * @return The serverAddress.
   */
  java.lang.String getServerAddress();
  /**
   *
   *
   * <pre>
   * The address of the server that is serving this tablet -- either an IP
   * address or DNS hostname and a port number.
   * </pre>
   *
   * <code>string server_address = 2;</code>
   *
   * @return The bytes for serverAddress.
   */
  com.google.protobuf.ByteString getServerAddressBytes();

  /**
   *
   *
   * <pre>
   * Where this tablet is located. In the Spanner managed service, this is the
   * name of a region, such as "us-central1". In Spanner Omni, this is a
   * previously created location.
   * </pre>
   *
   * <code>string location = 3;</code>
   *
   * @return The location.
   */
  java.lang.String getLocation();
  /**
   *
   *
   * <pre>
   * Where this tablet is located. In the Spanner managed service, this is the
   * name of a region, such as "us-central1". In Spanner Omni, this is a
   * previously created location.
   * </pre>
   *
   * <code>string location = 3;</code>
   *
   * @return The bytes for location.
   */
  com.google.protobuf.ByteString getLocationBytes();

  /**
   * <code>.google.spanner.v1.Tablet.Role role = 4;</code>
   *
   * @return The enum numeric value on the wire for role.
   */
  int getRoleValue();
  /**
   * <code>.google.spanner.v1.Tablet.Role role = 4;</code>
   *
   * @return The role.
   */
  com.google.spanner.v1.Tablet.Role getRole();

  /**
   *
   *
   * <pre>
   * `incarnation` indicates the freshness of the tablet information contained
   * in this proto. Incarnations can be compared lexicographically; if
   * incarnation A is greater than incarnation B, then the `Tablet`
   * corresponding to A is newer than the `Tablet` corresponding to B, and
   * should be used preferentially.
   * </pre>
   *
   * <code>bytes incarnation = 5;</code>
   *
   * @return The incarnation.
   */
  com.google.protobuf.ByteString getIncarnation();

  /**
   *
   *
   * <pre>
   * Distances help the client pick the closest tablet out of the list of
   * tablets for a given request. Tablets with lower distances should generally
   * be preferred. Tablets with the same distance are approximately equally
   * close; the client can choose arbitrarily.
   *
   * Distances do not correspond precisely to expected latency, geographical
   * distance, or anything else. Distances should be compared only between
   * tablets of the same group; they are not meaningful between different
   * groups.
   *
   * A value of zero indicates that the tablet may be in the same zone as
   * the client, and have minimum network latency. A value less than or equal to
   * five indicates that the tablet is thought to be in the same region as the
   * client, and may have a few milliseconds of network latency. Values greater
   * than five are most likely in a different region, with non-trivial network
   * latency.
   *
   * Clients should use the following algorithm:
   *   * If the request is using a directed read, eliminate any tablets that
   *     do not match the directed read's target zone and/or replica type.
   *   * (Read-write transactions only) Choose leader tablet if it has an
   *     distance &lt;=5.
   *   * Group and sort tablets by distance. Choose a random
   *     tablet with the lowest distance. If the request
   *     is not a directed read, only consider replicas with distances &lt;=5.
   *   * Send the request to the fallback endpoint.
   *
   * The tablet picked by this algorithm may be skipped, either because it is
   * marked as `skip` by the server or because the corresponding server is
   * unreachable, flow controlled, etc. Skipped tablets should be added to the
   * `skipped_tablet_uid` field in `RoutingHint`; the algorithm above should
   * then be re-run without including the skipped tablet(s) to pick the next
   * best tablet.
   * </pre>
   *
   * <code>uint32 distance = 6;</code>
   *
   * @return The distance.
   */
  int getDistance();

  /**
   *
   *
   * <pre>
   * If true, the tablet should not be chosen by the client. Typically, this
   * signals that the tablet is unhealthy in some way. Tablets with `skip`
   * set to true should be reported back to the server in
   * `RoutingHint.skipped_tablet_uid`; this cues the server to send updated
   * information for this tablet should it become usable again.
   * </pre>
   *
   * <code>bool skip = 7;</code>
   *
   * @return The skip.
   */
  boolean getSkip();
}
