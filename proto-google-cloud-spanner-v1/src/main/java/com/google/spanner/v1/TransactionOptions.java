/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/spanner/v1/transaction.proto

package com.google.spanner.v1;

/**
 *
 *
 * <pre>
 * # Transactions
 * Each session can have at most one active transaction at a time (note that
 * standalone reads and queries use a transaction internally and do count
 * towards the one transaction limit). After the active transaction is
 * completed, the session can immediately be re-used for the next transaction.
 * It is not necessary to create a new session for each transaction.
 * # Transaction Modes
 * Cloud Spanner supports three transaction modes:
 *   1. Locking read-write. This type of transaction is the only way
 *      to write data into Cloud Spanner. These transactions rely on
 *      pessimistic locking and, if necessary, two-phase commit.
 *      Locking read-write transactions may abort, requiring the
 *      application to retry.
 *   2. Snapshot read-only. This transaction type provides guaranteed
 *      consistency across several reads, but does not allow
 *      writes. Snapshot read-only transactions can be configured to
 *      read at timestamps in the past. Snapshot read-only
 *      transactions do not need to be committed.
 *   3. Partitioned DML. This type of transaction is used to execute
 *      a single Partitioned DML statement. Partitioned DML partitions
 *      the key space and runs the DML statement over each partition
 *      in parallel using separate, internal transactions that commit
 *      independently. Partitioned DML transactions do not need to be
 *      committed.
 * For transactions that only read, snapshot read-only transactions
 * provide simpler semantics and are almost always faster. In
 * particular, read-only transactions do not take locks, so they do
 * not conflict with read-write transactions. As a consequence of not
 * taking locks, they also do not abort, so retry loops are not needed.
 * Transactions may only read/write data in a single database. They
 * may, however, read/write data in different tables within that
 * database.
 * ## Locking Read-Write Transactions
 * Locking transactions may be used to atomically read-modify-write
 * data anywhere in a database. This type of transaction is externally
 * consistent.
 * Clients should attempt to minimize the amount of time a transaction
 * is active. Faster transactions commit with higher probability
 * and cause less contention. Cloud Spanner attempts to keep read locks
 * active as long as the transaction continues to do reads, and the
 * transaction has not been terminated by
 * [Commit][google.spanner.v1.Spanner.Commit] or
 * [Rollback][google.spanner.v1.Spanner.Rollback].  Long periods of
 * inactivity at the client may cause Cloud Spanner to release a
 * transaction's locks and abort it.
 * Conceptually, a read-write transaction consists of zero or more
 * reads or SQL statements followed by
 * [Commit][google.spanner.v1.Spanner.Commit]. At any time before
 * [Commit][google.spanner.v1.Spanner.Commit], the client can send a
 * [Rollback][google.spanner.v1.Spanner.Rollback] request to abort the
 * transaction.
 * ## Semantics
 * Cloud Spanner can commit the transaction if all read locks it acquired
 * are still valid at commit time, and it is able to acquire write
 * locks for all writes. Cloud Spanner can abort the transaction for any
 * reason. If a commit attempt returns `ABORTED`, Cloud Spanner guarantees
 * that the transaction has not modified any user data in Cloud Spanner.
 * Unless the transaction commits, Cloud Spanner makes no guarantees about
 * how long the transaction's locks were held for. It is an error to
 * use Cloud Spanner locks for any sort of mutual exclusion other than
 * between Cloud Spanner transactions themselves.
 * ## Retrying Aborted Transactions
 * When a transaction aborts, the application can choose to retry the
 * whole transaction again. To maximize the chances of successfully
 * committing the retry, the client should execute the retry in the
 * same session as the original attempt. The original session's lock
 * priority increases with each consecutive abort, meaning that each
 * attempt has a slightly better chance of success than the previous.
 * Under some circumstances (e.g., many transactions attempting to
 * modify the same row(s)), a transaction can abort many times in a
 * short period before successfully committing. Thus, it is not a good
 * idea to cap the number of retries a transaction can attempt;
 * instead, it is better to limit the total amount of wall time spent
 * retrying.
 * ## Idle Transactions
 * A transaction is considered idle if it has no outstanding reads or
 * SQL queries and has not started a read or SQL query within the last 10
 * seconds. Idle transactions can be aborted by Cloud Spanner so that they
 * don't hold on to locks indefinitely. In that case, the commit will
 * fail with error `ABORTED`.
 * If this behavior is undesirable, periodically executing a simple
 * SQL query in the transaction (e.g., `SELECT 1`) prevents the
 * transaction from becoming idle.
 * ## Snapshot Read-Only Transactions
 * Snapshot read-only transactions provides a simpler method than
 * locking read-write transactions for doing several consistent
 * reads. However, this type of transaction does not support writes.
 * Snapshot transactions do not take locks. Instead, they work by
 * choosing a Cloud Spanner timestamp, then executing all reads at that
 * timestamp. Since they do not acquire locks, they do not block
 * concurrent read-write transactions.
 * Unlike locking read-write transactions, snapshot read-only
 * transactions never abort. They can fail if the chosen read
 * timestamp is garbage collected; however, the default garbage
 * collection policy is generous enough that most applications do not
 * need to worry about this in practice.
 * Snapshot read-only transactions do not need to call
 * [Commit][google.spanner.v1.Spanner.Commit] or
 * [Rollback][google.spanner.v1.Spanner.Rollback] (and in fact are not
 * permitted to do so).
 * To execute a snapshot transaction, the client specifies a timestamp
 * bound, which tells Cloud Spanner how to choose a read timestamp.
 * The types of timestamp bound are:
 *   - Strong (the default).
 *   - Bounded staleness.
 *   - Exact staleness.
 * If the Cloud Spanner database to be read is geographically distributed,
 * stale read-only transactions can execute more quickly than strong
 * or read-write transaction, because they are able to execute far
 * from the leader replica.
 * Each type of timestamp bound is discussed in detail below.
 * ## Strong
 * Strong reads are guaranteed to see the effects of all transactions
 * that have committed before the start of the read. Furthermore, all
 * rows yielded by a single read are consistent with each other -- if
 * any part of the read observes a transaction, all parts of the read
 * see the transaction.
 * Strong reads are not repeatable: two consecutive strong read-only
 * transactions might return inconsistent results if there are
 * concurrent writes. If consistency across reads is required, the
 * reads should be executed within a transaction or at an exact read
 * timestamp.
 * See [TransactionOptions.ReadOnly.strong][google.spanner.v1.TransactionOptions.ReadOnly.strong].
 * ## Exact Staleness
 * These timestamp bounds execute reads at a user-specified
 * timestamp. Reads at a timestamp are guaranteed to see a consistent
 * prefix of the global transaction history: they observe
 * modifications done by all transactions with a commit timestamp &lt;=
 * the read timestamp, and observe none of the modifications done by
 * transactions with a larger commit timestamp. They will block until
 * all conflicting transactions that may be assigned commit timestamps
 * &lt;= the read timestamp have finished.
 * The timestamp can either be expressed as an absolute Cloud Spanner commit
 * timestamp or a staleness relative to the current time.
 * These modes do not require a "negotiation phase" to pick a
 * timestamp. As a result, they execute slightly faster than the
 * equivalent boundedly stale concurrency modes. On the other hand,
 * boundedly stale reads usually return fresher results.
 * See [TransactionOptions.ReadOnly.read_timestamp][google.spanner.v1.TransactionOptions.ReadOnly.read_timestamp] and
 * [TransactionOptions.ReadOnly.exact_staleness][google.spanner.v1.TransactionOptions.ReadOnly.exact_staleness].
 * ## Bounded Staleness
 * Bounded staleness modes allow Cloud Spanner to pick the read timestamp,
 * subject to a user-provided staleness bound. Cloud Spanner chooses the
 * newest timestamp within the staleness bound that allows execution
 * of the reads at the closest available replica without blocking.
 * All rows yielded are consistent with each other -- if any part of
 * the read observes a transaction, all parts of the read see the
 * transaction. Boundedly stale reads are not repeatable: two stale
 * reads, even if they use the same staleness bound, can execute at
 * different timestamps and thus return inconsistent results.
 * Boundedly stale reads execute in two phases: the first phase
 * negotiates a timestamp among all replicas needed to serve the
 * read. In the second phase, reads are executed at the negotiated
 * timestamp.
 * As a result of the two phase execution, bounded staleness reads are
 * usually a little slower than comparable exact staleness
 * reads. However, they are typically able to return fresher
 * results, and are more likely to execute at the closest replica.
 * Because the timestamp negotiation requires up-front knowledge of
 * which rows will be read, it can only be used with single-use
 * read-only transactions.
 * See [TransactionOptions.ReadOnly.max_staleness][google.spanner.v1.TransactionOptions.ReadOnly.max_staleness] and
 * [TransactionOptions.ReadOnly.min_read_timestamp][google.spanner.v1.TransactionOptions.ReadOnly.min_read_timestamp].
 * ## Old Read Timestamps and Garbage Collection
 * Cloud Spanner continuously garbage collects deleted and overwritten data
 * in the background to reclaim storage space. This process is known
 * as "version GC". By default, version GC reclaims versions after they
 * are one hour old. Because of this, Cloud Spanner cannot perform reads
 * at read timestamps more than one hour in the past. This
 * restriction also applies to in-progress reads and/or SQL queries whose
 * timestamp become too old while executing. Reads and SQL queries with
 * too-old read timestamps fail with the error `FAILED_PRECONDITION`.
 * ## Partitioned DML Transactions
 * Partitioned DML transactions are used to execute DML statements with a
 * different execution strategy that provides different, and often better,
 * scalability properties for large, table-wide operations than DML in a
 * ReadWrite transaction. Smaller scoped statements, such as an OLTP workload,
 * should prefer using ReadWrite transactions.
 * Partitioned DML partitions the keyspace and runs the DML statement on each
 * partition in separate, internal transactions. These transactions commit
 * automatically when complete, and run independently from one another.
 * To reduce lock contention, this execution strategy only acquires read locks
 * on rows that match the WHERE clause of the statement. Additionally, the
 * smaller per-partition transactions hold locks for less time.
 * That said, Partitioned DML is not a drop-in replacement for standard DML used
 * in ReadWrite transactions.
 *  - The DML statement must be fully-partitionable. Specifically, the statement
 *    must be expressible as the union of many statements which each access only
 *    a single row of the table.
 *  - The statement is not applied atomically to all rows of the table. Rather,
 *    the statement is applied atomically to partitions of the table, in
 *    independent transactions. Secondary index rows are updated atomically
 *    with the base table rows.
 *  - Partitioned DML does not guarantee exactly-once execution semantics
 *    against a partition. The statement will be applied at least once to each
 *    partition. It is strongly recommended that the DML statement should be
 *    idempotent to avoid unexpected results. For instance, it is potentially
 *    dangerous to run a statement such as
 *    `UPDATE table SET column = column + 1` as it could be run multiple times
 *    against some rows.
 *  - The partitions are committed automatically - there is no support for
 *    Commit or Rollback. If the call returns an error, or if the client issuing
 *    the ExecuteSql call dies, it is possible that some rows had the statement
 *    executed on them successfully. It is also possible that statement was
 *    never executed against other rows.
 *  - Partitioned DML transactions may only contain the execution of a single
 *    DML statement via ExecuteSql or ExecuteStreamingSql.
 *  - If any error is encountered during the execution of the partitioned DML
 *    operation (for instance, a UNIQUE INDEX violation, division by zero, or a
 *    value that cannot be stored due to schema constraints), then the
 *    operation is stopped at that point and an error is returned. It is
 *    possible that at this point, some partitions have been committed (or even
 *    committed multiple times), and other partitions have not been run at all.
 * Given the above, Partitioned DML is good fit for large, database-wide,
 * operations that are idempotent, such as deleting old rows from a very large
 * table.
 * </pre>
 *
 * Protobuf type {@code google.spanner.v1.TransactionOptions}
 */
public final class TransactionOptions extends com.google.protobuf.GeneratedMessageV3
    implements
    // @@protoc_insertion_point(message_implements:google.spanner.v1.TransactionOptions)
    TransactionOptionsOrBuilder {
  private static final long serialVersionUID = 0L;
  // Use TransactionOptions.newBuilder() to construct.
  private TransactionOptions(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
    super(builder);
  }

  private TransactionOptions() {}

  @Override
  @SuppressWarnings({"unused"})
  protected Object newInstance(UnusedPrivateParameter unused) {
    return new TransactionOptions();
  }

  @Override
  public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
    return this.unknownFields;
  }

  private TransactionOptions(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    this();
    if (extensionRegistry == null) {
      throw new NullPointerException();
    }
    com.google.protobuf.UnknownFieldSet.Builder unknownFields =
        com.google.protobuf.UnknownFieldSet.newBuilder();
    try {
      boolean done = false;
      while (!done) {
        int tag = input.readTag();
        switch (tag) {
          case 0:
            done = true;
            break;
          case 10:
            {
              ReadWrite.Builder subBuilder = null;
              if (modeCase_ == 1) {
                subBuilder = ((ReadWrite) mode_).toBuilder();
              }
              mode_ = input.readMessage(ReadWrite.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((ReadWrite) mode_);
                mode_ = subBuilder.buildPartial();
              }
              modeCase_ = 1;
              break;
            }
          case 18:
            {
              ReadOnly.Builder subBuilder = null;
              if (modeCase_ == 2) {
                subBuilder = ((ReadOnly) mode_).toBuilder();
              }
              mode_ = input.readMessage(ReadOnly.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((ReadOnly) mode_);
                mode_ = subBuilder.buildPartial();
              }
              modeCase_ = 2;
              break;
            }
          case 26:
            {
              PartitionedDml.Builder subBuilder = null;
              if (modeCase_ == 3) {
                subBuilder = ((PartitionedDml) mode_).toBuilder();
              }
              mode_ = input.readMessage(PartitionedDml.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((PartitionedDml) mode_);
                mode_ = subBuilder.buildPartial();
              }
              modeCase_ = 3;
              break;
            }
          default:
            {
              if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
        }
      }
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
      throw e.setUnfinishedMessage(this);
    } catch (java.io.IOException e) {
      throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
    } finally {
      this.unknownFields = unknownFields.build();
      makeExtensionsImmutable();
    }
  }

  public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return TransactionProto.internal_static_google_spanner_v1_TransactionOptions_descriptor;
  }

  @Override
  protected FieldAccessorTable internalGetFieldAccessorTable() {
    return TransactionProto.internal_static_google_spanner_v1_TransactionOptions_fieldAccessorTable
        .ensureFieldAccessorsInitialized(TransactionOptions.class, Builder.class);
  }

  public interface ReadWriteOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:google.spanner.v1.TransactionOptions.ReadWrite)
      com.google.protobuf.MessageOrBuilder {}
  /**
   *
   *
   * <pre>
   * Message type to initiate a read-write transaction. Currently this
   * transaction type has no options.
   * </pre>
   *
   * Protobuf type {@code google.spanner.v1.TransactionOptions.ReadWrite}
   */
  public static final class ReadWrite extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:google.spanner.v1.TransactionOptions.ReadWrite)
      ReadWriteOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use ReadWrite.newBuilder() to construct.
    private ReadWrite(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private ReadWrite() {}

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new ReadWrite();
    }

    @Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private ReadWrite(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return TransactionProto
          .internal_static_google_spanner_v1_TransactionOptions_ReadWrite_descriptor;
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return TransactionProto
          .internal_static_google_spanner_v1_TransactionOptions_ReadWrite_fieldAccessorTable
          .ensureFieldAccessorsInitialized(ReadWrite.class, Builder.class);
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      unknownFields.writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof ReadWrite)) {
        return super.equals(obj);
      }
      ReadWrite other = (ReadWrite) obj;

      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static ReadWrite parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static ReadWrite parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static ReadWrite parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static ReadWrite parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static ReadWrite parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static ReadWrite parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static ReadWrite parseFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static ReadWrite parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static ReadWrite parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static ReadWrite parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static ReadWrite parseFrom(com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static ReadWrite parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(ReadWrite prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * Message type to initiate a read-write transaction. Currently this
     * transaction type has no options.
     * </pre>
     *
     * Protobuf type {@code google.spanner.v1.TransactionOptions.ReadWrite}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:google.spanner.v1.TransactionOptions.ReadWrite)
        ReadWriteOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return TransactionProto
            .internal_static_google_spanner_v1_TransactionOptions_ReadWrite_descriptor;
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return TransactionProto
            .internal_static_google_spanner_v1_TransactionOptions_ReadWrite_fieldAccessorTable
            .ensureFieldAccessorsInitialized(ReadWrite.class, Builder.class);
      }

      // Construct using com.google.spanner.v1.TransactionOptions.ReadWrite.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {}
      }

      @Override
      public Builder clear() {
        super.clear();
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return TransactionProto
            .internal_static_google_spanner_v1_TransactionOptions_ReadWrite_descriptor;
      }

      @Override
      public ReadWrite getDefaultInstanceForType() {
        return ReadWrite.getDefaultInstance();
      }

      @Override
      public ReadWrite build() {
        ReadWrite result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public ReadWrite buildPartial() {
        ReadWrite result = new ReadWrite(this);
        onBuilt();
        return result;
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof ReadWrite) {
          return mergeFrom((ReadWrite) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(ReadWrite other) {
        if (other == ReadWrite.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        ReadWrite parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (ReadWrite) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:google.spanner.v1.TransactionOptions.ReadWrite)
    }

    // @@protoc_insertion_point(class_scope:google.spanner.v1.TransactionOptions.ReadWrite)
    private static final ReadWrite DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new ReadWrite();
    }

    public static ReadWrite getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ReadWrite> PARSER =
        new com.google.protobuf.AbstractParser<ReadWrite>() {
          @Override
          public ReadWrite parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new ReadWrite(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<ReadWrite> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<ReadWrite> getParserForType() {
      return PARSER;
    }

    @Override
    public ReadWrite getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface PartitionedDmlOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:google.spanner.v1.TransactionOptions.PartitionedDml)
      com.google.protobuf.MessageOrBuilder {}
  /**
   *
   *
   * <pre>
   * Message type to initiate a Partitioned DML transaction.
   * </pre>
   *
   * Protobuf type {@code google.spanner.v1.TransactionOptions.PartitionedDml}
   */
  public static final class PartitionedDml extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:google.spanner.v1.TransactionOptions.PartitionedDml)
      PartitionedDmlOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use PartitionedDml.newBuilder() to construct.
    private PartitionedDml(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private PartitionedDml() {}

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new PartitionedDml();
    }

    @Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private PartitionedDml(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return TransactionProto
          .internal_static_google_spanner_v1_TransactionOptions_PartitionedDml_descriptor;
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return TransactionProto
          .internal_static_google_spanner_v1_TransactionOptions_PartitionedDml_fieldAccessorTable
          .ensureFieldAccessorsInitialized(PartitionedDml.class, Builder.class);
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      unknownFields.writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof PartitionedDml)) {
        return super.equals(obj);
      }
      PartitionedDml other = (PartitionedDml) obj;

      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static PartitionedDml parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static PartitionedDml parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static PartitionedDml parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static PartitionedDml parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static PartitionedDml parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static PartitionedDml parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static PartitionedDml parseFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static PartitionedDml parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static PartitionedDml parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static PartitionedDml parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static PartitionedDml parseFrom(com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static PartitionedDml parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(PartitionedDml prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * Message type to initiate a Partitioned DML transaction.
     * </pre>
     *
     * Protobuf type {@code google.spanner.v1.TransactionOptions.PartitionedDml}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:google.spanner.v1.TransactionOptions.PartitionedDml)
        PartitionedDmlOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return TransactionProto
            .internal_static_google_spanner_v1_TransactionOptions_PartitionedDml_descriptor;
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return TransactionProto
            .internal_static_google_spanner_v1_TransactionOptions_PartitionedDml_fieldAccessorTable
            .ensureFieldAccessorsInitialized(PartitionedDml.class, Builder.class);
      }

      // Construct using com.google.spanner.v1.TransactionOptions.PartitionedDml.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {}
      }

      @Override
      public Builder clear() {
        super.clear();
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return TransactionProto
            .internal_static_google_spanner_v1_TransactionOptions_PartitionedDml_descriptor;
      }

      @Override
      public PartitionedDml getDefaultInstanceForType() {
        return PartitionedDml.getDefaultInstance();
      }

      @Override
      public PartitionedDml build() {
        PartitionedDml result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public PartitionedDml buildPartial() {
        PartitionedDml result = new PartitionedDml(this);
        onBuilt();
        return result;
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof PartitionedDml) {
          return mergeFrom((PartitionedDml) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(PartitionedDml other) {
        if (other == PartitionedDml.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        PartitionedDml parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (PartitionedDml) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:google.spanner.v1.TransactionOptions.PartitionedDml)
    }

    // @@protoc_insertion_point(class_scope:google.spanner.v1.TransactionOptions.PartitionedDml)
    private static final PartitionedDml DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new PartitionedDml();
    }

    public static PartitionedDml getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<PartitionedDml> PARSER =
        new com.google.protobuf.AbstractParser<PartitionedDml>() {
          @Override
          public PartitionedDml parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new PartitionedDml(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<PartitionedDml> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<PartitionedDml> getParserForType() {
      return PARSER;
    }

    @Override
    public PartitionedDml getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface ReadOnlyOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:google.spanner.v1.TransactionOptions.ReadOnly)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Read at a timestamp where all previously committed transactions
     * are visible.
     * </pre>
     *
     * <code>bool strong = 1;</code>
     *
     * @return Whether the strong field is set.
     */
    boolean hasStrong();
    /**
     *
     *
     * <pre>
     * Read at a timestamp where all previously committed transactions
     * are visible.
     * </pre>
     *
     * <code>bool strong = 1;</code>
     *
     * @return The strong.
     */
    boolean getStrong();

    /**
     *
     *
     * <pre>
     * Executes all reads at a timestamp &gt;= `min_read_timestamp`.
     * This is useful for requesting fresher data than some previous
     * read, or data that is fresh enough to observe the effects of some
     * previously committed transaction whose timestamp is known.
     * Note that this option can only be used in single-use transactions.
     * A timestamp in RFC3339 UTC &#92;"Zulu&#92;" format, accurate to nanoseconds.
     * Example: `"2014-10-02T15:01:23.045123456Z"`.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp min_read_timestamp = 2;</code>
     *
     * @return Whether the minReadTimestamp field is set.
     */
    boolean hasMinReadTimestamp();
    /**
     *
     *
     * <pre>
     * Executes all reads at a timestamp &gt;= `min_read_timestamp`.
     * This is useful for requesting fresher data than some previous
     * read, or data that is fresh enough to observe the effects of some
     * previously committed transaction whose timestamp is known.
     * Note that this option can only be used in single-use transactions.
     * A timestamp in RFC3339 UTC &#92;"Zulu&#92;" format, accurate to nanoseconds.
     * Example: `"2014-10-02T15:01:23.045123456Z"`.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp min_read_timestamp = 2;</code>
     *
     * @return The minReadTimestamp.
     */
    com.google.protobuf.Timestamp getMinReadTimestamp();
    /**
     *
     *
     * <pre>
     * Executes all reads at a timestamp &gt;= `min_read_timestamp`.
     * This is useful for requesting fresher data than some previous
     * read, or data that is fresh enough to observe the effects of some
     * previously committed transaction whose timestamp is known.
     * Note that this option can only be used in single-use transactions.
     * A timestamp in RFC3339 UTC &#92;"Zulu&#92;" format, accurate to nanoseconds.
     * Example: `"2014-10-02T15:01:23.045123456Z"`.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp min_read_timestamp = 2;</code>
     */
    com.google.protobuf.TimestampOrBuilder getMinReadTimestampOrBuilder();

    /**
     *
     *
     * <pre>
     * Read data at a timestamp &gt;= `NOW - max_staleness`
     * seconds. Guarantees that all writes that have committed more
     * than the specified number of seconds ago are visible. Because
     * Cloud Spanner chooses the exact timestamp, this mode works even if
     * the client's local clock is substantially skewed from Cloud Spanner
     * commit timestamps.
     * Useful for reading the freshest data available at a nearby
     * replica, while bounding the possible staleness if the local
     * replica has fallen behind.
     * Note that this option can only be used in single-use
     * transactions.
     * </pre>
     *
     * <code>.google.protobuf.Duration max_staleness = 3;</code>
     *
     * @return Whether the maxStaleness field is set.
     */
    boolean hasMaxStaleness();
    /**
     *
     *
     * <pre>
     * Read data at a timestamp &gt;= `NOW - max_staleness`
     * seconds. Guarantees that all writes that have committed more
     * than the specified number of seconds ago are visible. Because
     * Cloud Spanner chooses the exact timestamp, this mode works even if
     * the client's local clock is substantially skewed from Cloud Spanner
     * commit timestamps.
     * Useful for reading the freshest data available at a nearby
     * replica, while bounding the possible staleness if the local
     * replica has fallen behind.
     * Note that this option can only be used in single-use
     * transactions.
     * </pre>
     *
     * <code>.google.protobuf.Duration max_staleness = 3;</code>
     *
     * @return The maxStaleness.
     */
    com.google.protobuf.Duration getMaxStaleness();
    /**
     *
     *
     * <pre>
     * Read data at a timestamp &gt;= `NOW - max_staleness`
     * seconds. Guarantees that all writes that have committed more
     * than the specified number of seconds ago are visible. Because
     * Cloud Spanner chooses the exact timestamp, this mode works even if
     * the client's local clock is substantially skewed from Cloud Spanner
     * commit timestamps.
     * Useful for reading the freshest data available at a nearby
     * replica, while bounding the possible staleness if the local
     * replica has fallen behind.
     * Note that this option can only be used in single-use
     * transactions.
     * </pre>
     *
     * <code>.google.protobuf.Duration max_staleness = 3;</code>
     */
    com.google.protobuf.DurationOrBuilder getMaxStalenessOrBuilder();

    /**
     *
     *
     * <pre>
     * Executes all reads at the given timestamp. Unlike other modes,
     * reads at a specific timestamp are repeatable; the same read at
     * the same timestamp always returns the same data. If the
     * timestamp is in the future, the read will block until the
     * specified timestamp, modulo the read's deadline.
     * Useful for large scale consistent reads such as mapreduces, or
     * for coordinating many reads against a consistent snapshot of the
     * data.
     * A timestamp in RFC3339 UTC &#92;"Zulu&#92;" format, accurate to nanoseconds.
     * Example: `"2014-10-02T15:01:23.045123456Z"`.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp read_timestamp = 4;</code>
     *
     * @return Whether the readTimestamp field is set.
     */
    boolean hasReadTimestamp();
    /**
     *
     *
     * <pre>
     * Executes all reads at the given timestamp. Unlike other modes,
     * reads at a specific timestamp are repeatable; the same read at
     * the same timestamp always returns the same data. If the
     * timestamp is in the future, the read will block until the
     * specified timestamp, modulo the read's deadline.
     * Useful for large scale consistent reads such as mapreduces, or
     * for coordinating many reads against a consistent snapshot of the
     * data.
     * A timestamp in RFC3339 UTC &#92;"Zulu&#92;" format, accurate to nanoseconds.
     * Example: `"2014-10-02T15:01:23.045123456Z"`.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp read_timestamp = 4;</code>
     *
     * @return The readTimestamp.
     */
    com.google.protobuf.Timestamp getReadTimestamp();
    /**
     *
     *
     * <pre>
     * Executes all reads at the given timestamp. Unlike other modes,
     * reads at a specific timestamp are repeatable; the same read at
     * the same timestamp always returns the same data. If the
     * timestamp is in the future, the read will block until the
     * specified timestamp, modulo the read's deadline.
     * Useful for large scale consistent reads such as mapreduces, or
     * for coordinating many reads against a consistent snapshot of the
     * data.
     * A timestamp in RFC3339 UTC &#92;"Zulu&#92;" format, accurate to nanoseconds.
     * Example: `"2014-10-02T15:01:23.045123456Z"`.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp read_timestamp = 4;</code>
     */
    com.google.protobuf.TimestampOrBuilder getReadTimestampOrBuilder();

    /**
     *
     *
     * <pre>
     * Executes all reads at a timestamp that is `exact_staleness`
     * old. The timestamp is chosen soon after the read is started.
     * Guarantees that all writes that have committed more than the
     * specified number of seconds ago are visible. Because Cloud Spanner
     * chooses the exact timestamp, this mode works even if the client's
     * local clock is substantially skewed from Cloud Spanner commit
     * timestamps.
     * Useful for reading at nearby replicas without the distributed
     * timestamp negotiation overhead of `max_staleness`.
     * </pre>
     *
     * <code>.google.protobuf.Duration exact_staleness = 5;</code>
     *
     * @return Whether the exactStaleness field is set.
     */
    boolean hasExactStaleness();
    /**
     *
     *
     * <pre>
     * Executes all reads at a timestamp that is `exact_staleness`
     * old. The timestamp is chosen soon after the read is started.
     * Guarantees that all writes that have committed more than the
     * specified number of seconds ago are visible. Because Cloud Spanner
     * chooses the exact timestamp, this mode works even if the client's
     * local clock is substantially skewed from Cloud Spanner commit
     * timestamps.
     * Useful for reading at nearby replicas without the distributed
     * timestamp negotiation overhead of `max_staleness`.
     * </pre>
     *
     * <code>.google.protobuf.Duration exact_staleness = 5;</code>
     *
     * @return The exactStaleness.
     */
    com.google.protobuf.Duration getExactStaleness();
    /**
     *
     *
     * <pre>
     * Executes all reads at a timestamp that is `exact_staleness`
     * old. The timestamp is chosen soon after the read is started.
     * Guarantees that all writes that have committed more than the
     * specified number of seconds ago are visible. Because Cloud Spanner
     * chooses the exact timestamp, this mode works even if the client's
     * local clock is substantially skewed from Cloud Spanner commit
     * timestamps.
     * Useful for reading at nearby replicas without the distributed
     * timestamp negotiation overhead of `max_staleness`.
     * </pre>
     *
     * <code>.google.protobuf.Duration exact_staleness = 5;</code>
     */
    com.google.protobuf.DurationOrBuilder getExactStalenessOrBuilder();

    /**
     *
     *
     * <pre>
     * If true, the Cloud Spanner-selected read timestamp is included in
     * the [Transaction][google.spanner.v1.Transaction] message that describes the transaction.
     * </pre>
     *
     * <code>bool return_read_timestamp = 6;</code>
     *
     * @return The returnReadTimestamp.
     */
    boolean getReturnReadTimestamp();

    public ReadOnly.TimestampBoundCase getTimestampBoundCase();
  }
  /**
   *
   *
   * <pre>
   * Message type to initiate a read-only transaction.
   * </pre>
   *
   * Protobuf type {@code google.spanner.v1.TransactionOptions.ReadOnly}
   */
  public static final class ReadOnly extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:google.spanner.v1.TransactionOptions.ReadOnly)
      ReadOnlyOrBuilder {
    private static final long serialVersionUID = 0L;
    // Use ReadOnly.newBuilder() to construct.
    private ReadOnly(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private ReadOnly() {}

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new ReadOnly();
    }

    @Override
    public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    private ReadOnly(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8:
              {
                timestampBoundCase_ = 1;
                timestampBound_ = input.readBool();
                break;
              }
            case 18:
              {
                com.google.protobuf.Timestamp.Builder subBuilder = null;
                if (timestampBoundCase_ == 2) {
                  subBuilder = ((com.google.protobuf.Timestamp) timestampBound_).toBuilder();
                }
                timestampBound_ =
                    input.readMessage(com.google.protobuf.Timestamp.parser(), extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom((com.google.protobuf.Timestamp) timestampBound_);
                  timestampBound_ = subBuilder.buildPartial();
                }
                timestampBoundCase_ = 2;
                break;
              }
            case 26:
              {
                com.google.protobuf.Duration.Builder subBuilder = null;
                if (timestampBoundCase_ == 3) {
                  subBuilder = ((com.google.protobuf.Duration) timestampBound_).toBuilder();
                }
                timestampBound_ =
                    input.readMessage(com.google.protobuf.Duration.parser(), extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom((com.google.protobuf.Duration) timestampBound_);
                  timestampBound_ = subBuilder.buildPartial();
                }
                timestampBoundCase_ = 3;
                break;
              }
            case 34:
              {
                com.google.protobuf.Timestamp.Builder subBuilder = null;
                if (timestampBoundCase_ == 4) {
                  subBuilder = ((com.google.protobuf.Timestamp) timestampBound_).toBuilder();
                }
                timestampBound_ =
                    input.readMessage(com.google.protobuf.Timestamp.parser(), extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom((com.google.protobuf.Timestamp) timestampBound_);
                  timestampBound_ = subBuilder.buildPartial();
                }
                timestampBoundCase_ = 4;
                break;
              }
            case 42:
              {
                com.google.protobuf.Duration.Builder subBuilder = null;
                if (timestampBoundCase_ == 5) {
                  subBuilder = ((com.google.protobuf.Duration) timestampBound_).toBuilder();
                }
                timestampBound_ =
                    input.readMessage(com.google.protobuf.Duration.parser(), extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom((com.google.protobuf.Duration) timestampBound_);
                  timestampBound_ = subBuilder.buildPartial();
                }
                timestampBoundCase_ = 5;
                break;
              }
            case 48:
              {
                returnReadTimestamp_ = input.readBool();
                break;
              }
            default:
              {
                if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return TransactionProto
          .internal_static_google_spanner_v1_TransactionOptions_ReadOnly_descriptor;
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return TransactionProto
          .internal_static_google_spanner_v1_TransactionOptions_ReadOnly_fieldAccessorTable
          .ensureFieldAccessorsInitialized(ReadOnly.class, Builder.class);
    }

    private int timestampBoundCase_ = 0;
    private Object timestampBound_;

    public enum TimestampBoundCase
        implements com.google.protobuf.Internal.EnumLite, InternalOneOfEnum {
      STRONG(1),
      MIN_READ_TIMESTAMP(2),
      MAX_STALENESS(3),
      READ_TIMESTAMP(4),
      EXACT_STALENESS(5),
      TIMESTAMPBOUND_NOT_SET(0);
      private final int value;

      private TimestampBoundCase(int value) {
        this.value = value;
      }
      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @Deprecated
      public static TimestampBoundCase valueOf(int value) {
        return forNumber(value);
      }

      public static TimestampBoundCase forNumber(int value) {
        switch (value) {
          case 1:
            return STRONG;
          case 2:
            return MIN_READ_TIMESTAMP;
          case 3:
            return MAX_STALENESS;
          case 4:
            return READ_TIMESTAMP;
          case 5:
            return EXACT_STALENESS;
          case 0:
            return TIMESTAMPBOUND_NOT_SET;
          default:
            return null;
        }
      }

      public int getNumber() {
        return this.value;
      }
    };

    public TimestampBoundCase getTimestampBoundCase() {
      return TimestampBoundCase.forNumber(timestampBoundCase_);
    }

    public static final int STRONG_FIELD_NUMBER = 1;
    /**
     *
     *
     * <pre>
     * Read at a timestamp where all previously committed transactions
     * are visible.
     * </pre>
     *
     * <code>bool strong = 1;</code>
     *
     * @return Whether the strong field is set.
     */
    @java.lang.Override
    public boolean hasStrong() {
      return timestampBoundCase_ == 1;
    }
    /**
     *
     *
     * <pre>
     * Read at a timestamp where all previously committed transactions
     * are visible.
     * </pre>
     *
     * <code>bool strong = 1;</code>
     *
     * @return The strong.
     */
    @Override
    public boolean getStrong() {
      if (timestampBoundCase_ == 1) {
        return (Boolean) timestampBound_;
      }
      return false;
    }

    public static final int MIN_READ_TIMESTAMP_FIELD_NUMBER = 2;
    /**
     *
     *
     * <pre>
     * Executes all reads at a timestamp &gt;= `min_read_timestamp`.
     * This is useful for requesting fresher data than some previous
     * read, or data that is fresh enough to observe the effects of some
     * previously committed transaction whose timestamp is known.
     * Note that this option can only be used in single-use transactions.
     * A timestamp in RFC3339 UTC &#92;"Zulu&#92;" format, accurate to nanoseconds.
     * Example: `"2014-10-02T15:01:23.045123456Z"`.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp min_read_timestamp = 2;</code>
     *
     * @return Whether the minReadTimestamp field is set.
     */
    @Override
    public boolean hasMinReadTimestamp() {
      return timestampBoundCase_ == 2;
    }
    /**
     *
     *
     * <pre>
     * Executes all reads at a timestamp &gt;= `min_read_timestamp`.
     * This is useful for requesting fresher data than some previous
     * read, or data that is fresh enough to observe the effects of some
     * previously committed transaction whose timestamp is known.
     * Note that this option can only be used in single-use transactions.
     * A timestamp in RFC3339 UTC &#92;"Zulu&#92;" format, accurate to nanoseconds.
     * Example: `"2014-10-02T15:01:23.045123456Z"`.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp min_read_timestamp = 2;</code>
     *
     * @return The minReadTimestamp.
     */
    @Override
    public com.google.protobuf.Timestamp getMinReadTimestamp() {
      if (timestampBoundCase_ == 2) {
        return (com.google.protobuf.Timestamp) timestampBound_;
      }
      return com.google.protobuf.Timestamp.getDefaultInstance();
    }
    /**
     *
     *
     * <pre>
     * Executes all reads at a timestamp &gt;= `min_read_timestamp`.
     * This is useful for requesting fresher data than some previous
     * read, or data that is fresh enough to observe the effects of some
     * previously committed transaction whose timestamp is known.
     * Note that this option can only be used in single-use transactions.
     * A timestamp in RFC3339 UTC &#92;"Zulu&#92;" format, accurate to nanoseconds.
     * Example: `"2014-10-02T15:01:23.045123456Z"`.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp min_read_timestamp = 2;</code>
     */
    @Override
    public com.google.protobuf.TimestampOrBuilder getMinReadTimestampOrBuilder() {
      if (timestampBoundCase_ == 2) {
        return (com.google.protobuf.Timestamp) timestampBound_;
      }
      return com.google.protobuf.Timestamp.getDefaultInstance();
    }

    public static final int MAX_STALENESS_FIELD_NUMBER = 3;
    /**
     *
     *
     * <pre>
     * Read data at a timestamp &gt;= `NOW - max_staleness`
     * seconds. Guarantees that all writes that have committed more
     * than the specified number of seconds ago are visible. Because
     * Cloud Spanner chooses the exact timestamp, this mode works even if
     * the client's local clock is substantially skewed from Cloud Spanner
     * commit timestamps.
     * Useful for reading the freshest data available at a nearby
     * replica, while bounding the possible staleness if the local
     * replica has fallen behind.
     * Note that this option can only be used in single-use
     * transactions.
     * </pre>
     *
     * <code>.google.protobuf.Duration max_staleness = 3;</code>
     *
     * @return Whether the maxStaleness field is set.
     */
    @Override
    public boolean hasMaxStaleness() {
      return timestampBoundCase_ == 3;
    }
    /**
     *
     *
     * <pre>
     * Read data at a timestamp &gt;= `NOW - max_staleness`
     * seconds. Guarantees that all writes that have committed more
     * than the specified number of seconds ago are visible. Because
     * Cloud Spanner chooses the exact timestamp, this mode works even if
     * the client's local clock is substantially skewed from Cloud Spanner
     * commit timestamps.
     * Useful for reading the freshest data available at a nearby
     * replica, while bounding the possible staleness if the local
     * replica has fallen behind.
     * Note that this option can only be used in single-use
     * transactions.
     * </pre>
     *
     * <code>.google.protobuf.Duration max_staleness = 3;</code>
     *
     * @return The maxStaleness.
     */
    @Override
    public com.google.protobuf.Duration getMaxStaleness() {
      if (timestampBoundCase_ == 3) {
        return (com.google.protobuf.Duration) timestampBound_;
      }
      return com.google.protobuf.Duration.getDefaultInstance();
    }
    /**
     *
     *
     * <pre>
     * Read data at a timestamp &gt;= `NOW - max_staleness`
     * seconds. Guarantees that all writes that have committed more
     * than the specified number of seconds ago are visible. Because
     * Cloud Spanner chooses the exact timestamp, this mode works even if
     * the client's local clock is substantially skewed from Cloud Spanner
     * commit timestamps.
     * Useful for reading the freshest data available at a nearby
     * replica, while bounding the possible staleness if the local
     * replica has fallen behind.
     * Note that this option can only be used in single-use
     * transactions.
     * </pre>
     *
     * <code>.google.protobuf.Duration max_staleness = 3;</code>
     */
    @Override
    public com.google.protobuf.DurationOrBuilder getMaxStalenessOrBuilder() {
      if (timestampBoundCase_ == 3) {
        return (com.google.protobuf.Duration) timestampBound_;
      }
      return com.google.protobuf.Duration.getDefaultInstance();
    }

    public static final int READ_TIMESTAMP_FIELD_NUMBER = 4;
    /**
     *
     *
     * <pre>
     * Executes all reads at the given timestamp. Unlike other modes,
     * reads at a specific timestamp are repeatable; the same read at
     * the same timestamp always returns the same data. If the
     * timestamp is in the future, the read will block until the
     * specified timestamp, modulo the read's deadline.
     * Useful for large scale consistent reads such as mapreduces, or
     * for coordinating many reads against a consistent snapshot of the
     * data.
     * A timestamp in RFC3339 UTC &#92;"Zulu&#92;" format, accurate to nanoseconds.
     * Example: `"2014-10-02T15:01:23.045123456Z"`.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp read_timestamp = 4;</code>
     *
     * @return Whether the readTimestamp field is set.
     */
    @Override
    public boolean hasReadTimestamp() {
      return timestampBoundCase_ == 4;
    }
    /**
     *
     *
     * <pre>
     * Executes all reads at the given timestamp. Unlike other modes,
     * reads at a specific timestamp are repeatable; the same read at
     * the same timestamp always returns the same data. If the
     * timestamp is in the future, the read will block until the
     * specified timestamp, modulo the read's deadline.
     * Useful for large scale consistent reads such as mapreduces, or
     * for coordinating many reads against a consistent snapshot of the
     * data.
     * A timestamp in RFC3339 UTC &#92;"Zulu&#92;" format, accurate to nanoseconds.
     * Example: `"2014-10-02T15:01:23.045123456Z"`.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp read_timestamp = 4;</code>
     *
     * @return The readTimestamp.
     */
    @Override
    public com.google.protobuf.Timestamp getReadTimestamp() {
      if (timestampBoundCase_ == 4) {
        return (com.google.protobuf.Timestamp) timestampBound_;
      }
      return com.google.protobuf.Timestamp.getDefaultInstance();
    }
    /**
     *
     *
     * <pre>
     * Executes all reads at the given timestamp. Unlike other modes,
     * reads at a specific timestamp are repeatable; the same read at
     * the same timestamp always returns the same data. If the
     * timestamp is in the future, the read will block until the
     * specified timestamp, modulo the read's deadline.
     * Useful for large scale consistent reads such as mapreduces, or
     * for coordinating many reads against a consistent snapshot of the
     * data.
     * A timestamp in RFC3339 UTC &#92;"Zulu&#92;" format, accurate to nanoseconds.
     * Example: `"2014-10-02T15:01:23.045123456Z"`.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp read_timestamp = 4;</code>
     */
    @Override
    public com.google.protobuf.TimestampOrBuilder getReadTimestampOrBuilder() {
      if (timestampBoundCase_ == 4) {
        return (com.google.protobuf.Timestamp) timestampBound_;
      }
      return com.google.protobuf.Timestamp.getDefaultInstance();
    }

    public static final int EXACT_STALENESS_FIELD_NUMBER = 5;
    /**
     *
     *
     * <pre>
     * Executes all reads at a timestamp that is `exact_staleness`
     * old. The timestamp is chosen soon after the read is started.
     * Guarantees that all writes that have committed more than the
     * specified number of seconds ago are visible. Because Cloud Spanner
     * chooses the exact timestamp, this mode works even if the client's
     * local clock is substantially skewed from Cloud Spanner commit
     * timestamps.
     * Useful for reading at nearby replicas without the distributed
     * timestamp negotiation overhead of `max_staleness`.
     * </pre>
     *
     * <code>.google.protobuf.Duration exact_staleness = 5;</code>
     *
     * @return Whether the exactStaleness field is set.
     */
    @Override
    public boolean hasExactStaleness() {
      return timestampBoundCase_ == 5;
    }
    /**
     *
     *
     * <pre>
     * Executes all reads at a timestamp that is `exact_staleness`
     * old. The timestamp is chosen soon after the read is started.
     * Guarantees that all writes that have committed more than the
     * specified number of seconds ago are visible. Because Cloud Spanner
     * chooses the exact timestamp, this mode works even if the client's
     * local clock is substantially skewed from Cloud Spanner commit
     * timestamps.
     * Useful for reading at nearby replicas without the distributed
     * timestamp negotiation overhead of `max_staleness`.
     * </pre>
     *
     * <code>.google.protobuf.Duration exact_staleness = 5;</code>
     *
     * @return The exactStaleness.
     */
    @Override
    public com.google.protobuf.Duration getExactStaleness() {
      if (timestampBoundCase_ == 5) {
        return (com.google.protobuf.Duration) timestampBound_;
      }
      return com.google.protobuf.Duration.getDefaultInstance();
    }
    /**
     *
     *
     * <pre>
     * Executes all reads at a timestamp that is `exact_staleness`
     * old. The timestamp is chosen soon after the read is started.
     * Guarantees that all writes that have committed more than the
     * specified number of seconds ago are visible. Because Cloud Spanner
     * chooses the exact timestamp, this mode works even if the client's
     * local clock is substantially skewed from Cloud Spanner commit
     * timestamps.
     * Useful for reading at nearby replicas without the distributed
     * timestamp negotiation overhead of `max_staleness`.
     * </pre>
     *
     * <code>.google.protobuf.Duration exact_staleness = 5;</code>
     */
    @Override
    public com.google.protobuf.DurationOrBuilder getExactStalenessOrBuilder() {
      if (timestampBoundCase_ == 5) {
        return (com.google.protobuf.Duration) timestampBound_;
      }
      return com.google.protobuf.Duration.getDefaultInstance();
    }

    public static final int RETURN_READ_TIMESTAMP_FIELD_NUMBER = 6;
    private boolean returnReadTimestamp_;
    /**
     *
     *
     * <pre>
     * If true, the Cloud Spanner-selected read timestamp is included in
     * the [Transaction][google.spanner.v1.Transaction] message that describes the transaction.
     * </pre>
     *
     * <code>bool return_read_timestamp = 6;</code>
     *
     * @return The returnReadTimestamp.
     */
    @Override
    public boolean getReturnReadTimestamp() {
      return returnReadTimestamp_;
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (timestampBoundCase_ == 1) {
        output.writeBool(1, (boolean) ((Boolean) timestampBound_));
      }
      if (timestampBoundCase_ == 2) {
        output.writeMessage(2, (com.google.protobuf.Timestamp) timestampBound_);
      }
      if (timestampBoundCase_ == 3) {
        output.writeMessage(3, (com.google.protobuf.Duration) timestampBound_);
      }
      if (timestampBoundCase_ == 4) {
        output.writeMessage(4, (com.google.protobuf.Timestamp) timestampBound_);
      }
      if (timestampBoundCase_ == 5) {
        output.writeMessage(5, (com.google.protobuf.Duration) timestampBound_);
      }
      if (returnReadTimestamp_ != false) {
        output.writeBool(6, returnReadTimestamp_);
      }
      unknownFields.writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (timestampBoundCase_ == 1) {
        size +=
            com.google.protobuf.CodedOutputStream.computeBoolSize(
                1, (boolean) ((Boolean) timestampBound_));
      }
      if (timestampBoundCase_ == 2) {
        size +=
            com.google.protobuf.CodedOutputStream.computeMessageSize(
                2, (com.google.protobuf.Timestamp) timestampBound_);
      }
      if (timestampBoundCase_ == 3) {
        size +=
            com.google.protobuf.CodedOutputStream.computeMessageSize(
                3, (com.google.protobuf.Duration) timestampBound_);
      }
      if (timestampBoundCase_ == 4) {
        size +=
            com.google.protobuf.CodedOutputStream.computeMessageSize(
                4, (com.google.protobuf.Timestamp) timestampBound_);
      }
      if (timestampBoundCase_ == 5) {
        size +=
            com.google.protobuf.CodedOutputStream.computeMessageSize(
                5, (com.google.protobuf.Duration) timestampBound_);
      }
      if (returnReadTimestamp_ != false) {
        size += com.google.protobuf.CodedOutputStream.computeBoolSize(6, returnReadTimestamp_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof ReadOnly)) {
        return super.equals(obj);
      }
      ReadOnly other = (ReadOnly) obj;

      if (getReturnReadTimestamp() != other.getReturnReadTimestamp()) return false;
      if (!getTimestampBoundCase().equals(other.getTimestampBoundCase())) return false;
      switch (timestampBoundCase_) {
        case 1:
          if (getStrong() != other.getStrong()) return false;
          break;
        case 2:
          if (!getMinReadTimestamp().equals(other.getMinReadTimestamp())) return false;
          break;
        case 3:
          if (!getMaxStaleness().equals(other.getMaxStaleness())) return false;
          break;
        case 4:
          if (!getReadTimestamp().equals(other.getReadTimestamp())) return false;
          break;
        case 5:
          if (!getExactStaleness().equals(other.getExactStaleness())) return false;
          break;
        case 0:
        default:
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + RETURN_READ_TIMESTAMP_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(getReturnReadTimestamp());
      switch (timestampBoundCase_) {
        case 1:
          hash = (37 * hash) + STRONG_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(getStrong());
          break;
        case 2:
          hash = (37 * hash) + MIN_READ_TIMESTAMP_FIELD_NUMBER;
          hash = (53 * hash) + getMinReadTimestamp().hashCode();
          break;
        case 3:
          hash = (37 * hash) + MAX_STALENESS_FIELD_NUMBER;
          hash = (53 * hash) + getMaxStaleness().hashCode();
          break;
        case 4:
          hash = (37 * hash) + READ_TIMESTAMP_FIELD_NUMBER;
          hash = (53 * hash) + getReadTimestamp().hashCode();
          break;
        case 5:
          hash = (37 * hash) + EXACT_STALENESS_FIELD_NUMBER;
          hash = (53 * hash) + getExactStaleness().hashCode();
          break;
        case 0:
        default:
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static ReadOnly parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static ReadOnly parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static ReadOnly parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static ReadOnly parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static ReadOnly parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static ReadOnly parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static ReadOnly parseFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static ReadOnly parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static ReadOnly parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static ReadOnly parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static ReadOnly parseFrom(com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static ReadOnly parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(ReadOnly prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     *
     *
     * <pre>
     * Message type to initiate a read-only transaction.
     * </pre>
     *
     * Protobuf type {@code google.spanner.v1.TransactionOptions.ReadOnly}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:google.spanner.v1.TransactionOptions.ReadOnly)
        ReadOnlyOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return TransactionProto
            .internal_static_google_spanner_v1_TransactionOptions_ReadOnly_descriptor;
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return TransactionProto
            .internal_static_google_spanner_v1_TransactionOptions_ReadOnly_fieldAccessorTable
            .ensureFieldAccessorsInitialized(ReadOnly.class, Builder.class);
      }

      // Construct using com.google.spanner.v1.TransactionOptions.ReadOnly.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {}
      }

      @Override
      public Builder clear() {
        super.clear();
        returnReadTimestamp_ = false;

        timestampBoundCase_ = 0;
        timestampBound_ = null;
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return TransactionProto
            .internal_static_google_spanner_v1_TransactionOptions_ReadOnly_descriptor;
      }

      @Override
      public ReadOnly getDefaultInstanceForType() {
        return ReadOnly.getDefaultInstance();
      }

      @Override
      public ReadOnly build() {
        ReadOnly result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public ReadOnly buildPartial() {
        ReadOnly result = new ReadOnly(this);
        if (timestampBoundCase_ == 1) {
          result.timestampBound_ = timestampBound_;
        }
        if (timestampBoundCase_ == 2) {
          if (minReadTimestampBuilder_ == null) {
            result.timestampBound_ = timestampBound_;
          } else {
            result.timestampBound_ = minReadTimestampBuilder_.build();
          }
        }
        if (timestampBoundCase_ == 3) {
          if (maxStalenessBuilder_ == null) {
            result.timestampBound_ = timestampBound_;
          } else {
            result.timestampBound_ = maxStalenessBuilder_.build();
          }
        }
        if (timestampBoundCase_ == 4) {
          if (readTimestampBuilder_ == null) {
            result.timestampBound_ = timestampBound_;
          } else {
            result.timestampBound_ = readTimestampBuilder_.build();
          }
        }
        if (timestampBoundCase_ == 5) {
          if (exactStalenessBuilder_ == null) {
            result.timestampBound_ = timestampBound_;
          } else {
            result.timestampBound_ = exactStalenessBuilder_.build();
          }
        }
        result.returnReadTimestamp_ = returnReadTimestamp_;
        result.timestampBoundCase_ = timestampBoundCase_;
        onBuilt();
        return result;
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof ReadOnly) {
          return mergeFrom((ReadOnly) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(ReadOnly other) {
        if (other == ReadOnly.getDefaultInstance()) return this;
        if (other.getReturnReadTimestamp() != false) {
          setReturnReadTimestamp(other.getReturnReadTimestamp());
        }
        switch (other.getTimestampBoundCase()) {
          case STRONG:
            {
              setStrong(other.getStrong());
              break;
            }
          case MIN_READ_TIMESTAMP:
            {
              mergeMinReadTimestamp(other.getMinReadTimestamp());
              break;
            }
          case MAX_STALENESS:
            {
              mergeMaxStaleness(other.getMaxStaleness());
              break;
            }
          case READ_TIMESTAMP:
            {
              mergeReadTimestamp(other.getReadTimestamp());
              break;
            }
          case EXACT_STALENESS:
            {
              mergeExactStaleness(other.getExactStaleness());
              break;
            }
          case TIMESTAMPBOUND_NOT_SET:
            {
              break;
            }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        ReadOnly parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (ReadOnly) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int timestampBoundCase_ = 0;
      private Object timestampBound_;

      public TimestampBoundCase getTimestampBoundCase() {
        return TimestampBoundCase.forNumber(timestampBoundCase_);
      }

      public Builder clearTimestampBound() {
        timestampBoundCase_ = 0;
        timestampBound_ = null;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Read at a timestamp where all previously committed transactions
       * are visible.
       * </pre>
       *
       * <code>bool strong = 1;</code>
       *
       * @return Whether the strong field is set.
       */
      public boolean hasStrong() {
        return timestampBoundCase_ == 1;
      }
      /**
       *
       *
       * <pre>
       * Read at a timestamp where all previously committed transactions
       * are visible.
       * </pre>
       *
       * <code>bool strong = 1;</code>
       *
       * @return The strong.
       */
      public boolean getStrong() {
        if (timestampBoundCase_ == 1) {
          return (Boolean) timestampBound_;
        }
        return false;
      }
      /**
       *
       *
       * <pre>
       * Read at a timestamp where all previously committed transactions
       * are visible.
       * </pre>
       *
       * <code>bool strong = 1;</code>
       *
       * @param value The strong to set.
       * @return This builder for chaining.
       */
      public Builder setStrong(boolean value) {
        timestampBoundCase_ = 1;
        timestampBound_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * Read at a timestamp where all previously committed transactions
       * are visible.
       * </pre>
       *
       * <code>bool strong = 1;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearStrong() {
        if (timestampBoundCase_ == 1) {
          timestampBoundCase_ = 0;
          timestampBound_ = null;
          onChanged();
        }
        return this;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.Timestamp,
              com.google.protobuf.Timestamp.Builder,
              com.google.protobuf.TimestampOrBuilder>
          minReadTimestampBuilder_;
      /**
       *
       *
       * <pre>
       * Executes all reads at a timestamp &gt;= `min_read_timestamp`.
       * This is useful for requesting fresher data than some previous
       * read, or data that is fresh enough to observe the effects of some
       * previously committed transaction whose timestamp is known.
       * Note that this option can only be used in single-use transactions.
       * A timestamp in RFC3339 UTC &#92;"Zulu&#92;" format, accurate to nanoseconds.
       * Example: `"2014-10-02T15:01:23.045123456Z"`.
       * </pre>
       *
       * <code>.google.protobuf.Timestamp min_read_timestamp = 2;</code>
       *
       * @return Whether the minReadTimestamp field is set.
       */
      @Override
      public boolean hasMinReadTimestamp() {
        return timestampBoundCase_ == 2;
      }
      /**
       *
       *
       * <pre>
       * Executes all reads at a timestamp &gt;= `min_read_timestamp`.
       * This is useful for requesting fresher data than some previous
       * read, or data that is fresh enough to observe the effects of some
       * previously committed transaction whose timestamp is known.
       * Note that this option can only be used in single-use transactions.
       * A timestamp in RFC3339 UTC &#92;"Zulu&#92;" format, accurate to nanoseconds.
       * Example: `"2014-10-02T15:01:23.045123456Z"`.
       * </pre>
       *
       * <code>.google.protobuf.Timestamp min_read_timestamp = 2;</code>
       *
       * @return The minReadTimestamp.
       */
      @Override
      public com.google.protobuf.Timestamp getMinReadTimestamp() {
        if (minReadTimestampBuilder_ == null) {
          if (timestampBoundCase_ == 2) {
            return (com.google.protobuf.Timestamp) timestampBound_;
          }
          return com.google.protobuf.Timestamp.getDefaultInstance();
        } else {
          if (timestampBoundCase_ == 2) {
            return minReadTimestampBuilder_.getMessage();
          }
          return com.google.protobuf.Timestamp.getDefaultInstance();
        }
      }
      /**
       *
       *
       * <pre>
       * Executes all reads at a timestamp &gt;= `min_read_timestamp`.
       * This is useful for requesting fresher data than some previous
       * read, or data that is fresh enough to observe the effects of some
       * previously committed transaction whose timestamp is known.
       * Note that this option can only be used in single-use transactions.
       * A timestamp in RFC3339 UTC &#92;"Zulu&#92;" format, accurate to nanoseconds.
       * Example: `"2014-10-02T15:01:23.045123456Z"`.
       * </pre>
       *
       * <code>.google.protobuf.Timestamp min_read_timestamp = 2;</code>
       */
      public Builder setMinReadTimestamp(com.google.protobuf.Timestamp value) {
        if (minReadTimestampBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          timestampBound_ = value;
          onChanged();
        } else {
          minReadTimestampBuilder_.setMessage(value);
        }
        timestampBoundCase_ = 2;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Executes all reads at a timestamp &gt;= `min_read_timestamp`.
       * This is useful for requesting fresher data than some previous
       * read, or data that is fresh enough to observe the effects of some
       * previously committed transaction whose timestamp is known.
       * Note that this option can only be used in single-use transactions.
       * A timestamp in RFC3339 UTC &#92;"Zulu&#92;" format, accurate to nanoseconds.
       * Example: `"2014-10-02T15:01:23.045123456Z"`.
       * </pre>
       *
       * <code>.google.protobuf.Timestamp min_read_timestamp = 2;</code>
       */
      public Builder setMinReadTimestamp(com.google.protobuf.Timestamp.Builder builderForValue) {
        if (minReadTimestampBuilder_ == null) {
          timestampBound_ = builderForValue.build();
          onChanged();
        } else {
          minReadTimestampBuilder_.setMessage(builderForValue.build());
        }
        timestampBoundCase_ = 2;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Executes all reads at a timestamp &gt;= `min_read_timestamp`.
       * This is useful for requesting fresher data than some previous
       * read, or data that is fresh enough to observe the effects of some
       * previously committed transaction whose timestamp is known.
       * Note that this option can only be used in single-use transactions.
       * A timestamp in RFC3339 UTC &#92;"Zulu&#92;" format, accurate to nanoseconds.
       * Example: `"2014-10-02T15:01:23.045123456Z"`.
       * </pre>
       *
       * <code>.google.protobuf.Timestamp min_read_timestamp = 2;</code>
       */
      public Builder mergeMinReadTimestamp(com.google.protobuf.Timestamp value) {
        if (minReadTimestampBuilder_ == null) {
          if (timestampBoundCase_ == 2
              && timestampBound_ != com.google.protobuf.Timestamp.getDefaultInstance()) {
            timestampBound_ =
                com.google.protobuf.Timestamp.newBuilder(
                        (com.google.protobuf.Timestamp) timestampBound_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            timestampBound_ = value;
          }
          onChanged();
        } else {
          if (timestampBoundCase_ == 2) {
            minReadTimestampBuilder_.mergeFrom(value);
          }
          minReadTimestampBuilder_.setMessage(value);
        }
        timestampBoundCase_ = 2;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Executes all reads at a timestamp &gt;= `min_read_timestamp`.
       * This is useful for requesting fresher data than some previous
       * read, or data that is fresh enough to observe the effects of some
       * previously committed transaction whose timestamp is known.
       * Note that this option can only be used in single-use transactions.
       * A timestamp in RFC3339 UTC &#92;"Zulu&#92;" format, accurate to nanoseconds.
       * Example: `"2014-10-02T15:01:23.045123456Z"`.
       * </pre>
       *
       * <code>.google.protobuf.Timestamp min_read_timestamp = 2;</code>
       */
      public Builder clearMinReadTimestamp() {
        if (minReadTimestampBuilder_ == null) {
          if (timestampBoundCase_ == 2) {
            timestampBoundCase_ = 0;
            timestampBound_ = null;
            onChanged();
          }
        } else {
          if (timestampBoundCase_ == 2) {
            timestampBoundCase_ = 0;
            timestampBound_ = null;
          }
          minReadTimestampBuilder_.clear();
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Executes all reads at a timestamp &gt;= `min_read_timestamp`.
       * This is useful for requesting fresher data than some previous
       * read, or data that is fresh enough to observe the effects of some
       * previously committed transaction whose timestamp is known.
       * Note that this option can only be used in single-use transactions.
       * A timestamp in RFC3339 UTC &#92;"Zulu&#92;" format, accurate to nanoseconds.
       * Example: `"2014-10-02T15:01:23.045123456Z"`.
       * </pre>
       *
       * <code>.google.protobuf.Timestamp min_read_timestamp = 2;</code>
       */
      public com.google.protobuf.Timestamp.Builder getMinReadTimestampBuilder() {
        return getMinReadTimestampFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * Executes all reads at a timestamp &gt;= `min_read_timestamp`.
       * This is useful for requesting fresher data than some previous
       * read, or data that is fresh enough to observe the effects of some
       * previously committed transaction whose timestamp is known.
       * Note that this option can only be used in single-use transactions.
       * A timestamp in RFC3339 UTC &#92;"Zulu&#92;" format, accurate to nanoseconds.
       * Example: `"2014-10-02T15:01:23.045123456Z"`.
       * </pre>
       *
       * <code>.google.protobuf.Timestamp min_read_timestamp = 2;</code>
       */
      @Override
      public com.google.protobuf.TimestampOrBuilder getMinReadTimestampOrBuilder() {
        if ((timestampBoundCase_ == 2) && (minReadTimestampBuilder_ != null)) {
          return minReadTimestampBuilder_.getMessageOrBuilder();
        } else {
          if (timestampBoundCase_ == 2) {
            return (com.google.protobuf.Timestamp) timestampBound_;
          }
          return com.google.protobuf.Timestamp.getDefaultInstance();
        }
      }
      /**
       *
       *
       * <pre>
       * Executes all reads at a timestamp &gt;= `min_read_timestamp`.
       * This is useful for requesting fresher data than some previous
       * read, or data that is fresh enough to observe the effects of some
       * previously committed transaction whose timestamp is known.
       * Note that this option can only be used in single-use transactions.
       * A timestamp in RFC3339 UTC &#92;"Zulu&#92;" format, accurate to nanoseconds.
       * Example: `"2014-10-02T15:01:23.045123456Z"`.
       * </pre>
       *
       * <code>.google.protobuf.Timestamp min_read_timestamp = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.Timestamp,
              com.google.protobuf.Timestamp.Builder,
              com.google.protobuf.TimestampOrBuilder>
          getMinReadTimestampFieldBuilder() {
        if (minReadTimestampBuilder_ == null) {
          if (!(timestampBoundCase_ == 2)) {
            timestampBound_ = com.google.protobuf.Timestamp.getDefaultInstance();
          }
          minReadTimestampBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  com.google.protobuf.Timestamp,
                  com.google.protobuf.Timestamp.Builder,
                  com.google.protobuf.TimestampOrBuilder>(
                  (com.google.protobuf.Timestamp) timestampBound_,
                  getParentForChildren(),
                  isClean());
          timestampBound_ = null;
        }
        timestampBoundCase_ = 2;
        onChanged();
        ;
        return minReadTimestampBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.Duration,
              com.google.protobuf.Duration.Builder,
              com.google.protobuf.DurationOrBuilder>
          maxStalenessBuilder_;
      /**
       *
       *
       * <pre>
       * Read data at a timestamp &gt;= `NOW - max_staleness`
       * seconds. Guarantees that all writes that have committed more
       * than the specified number of seconds ago are visible. Because
       * Cloud Spanner chooses the exact timestamp, this mode works even if
       * the client's local clock is substantially skewed from Cloud Spanner
       * commit timestamps.
       * Useful for reading the freshest data available at a nearby
       * replica, while bounding the possible staleness if the local
       * replica has fallen behind.
       * Note that this option can only be used in single-use
       * transactions.
       * </pre>
       *
       * <code>.google.protobuf.Duration max_staleness = 3;</code>
       *
       * @return Whether the maxStaleness field is set.
       */
      @Override
      public boolean hasMaxStaleness() {
        return timestampBoundCase_ == 3;
      }
      /**
       *
       *
       * <pre>
       * Read data at a timestamp &gt;= `NOW - max_staleness`
       * seconds. Guarantees that all writes that have committed more
       * than the specified number of seconds ago are visible. Because
       * Cloud Spanner chooses the exact timestamp, this mode works even if
       * the client's local clock is substantially skewed from Cloud Spanner
       * commit timestamps.
       * Useful for reading the freshest data available at a nearby
       * replica, while bounding the possible staleness if the local
       * replica has fallen behind.
       * Note that this option can only be used in single-use
       * transactions.
       * </pre>
       *
       * <code>.google.protobuf.Duration max_staleness = 3;</code>
       *
       * @return The maxStaleness.
       */
      @Override
      public com.google.protobuf.Duration getMaxStaleness() {
        if (maxStalenessBuilder_ == null) {
          if (timestampBoundCase_ == 3) {
            return (com.google.protobuf.Duration) timestampBound_;
          }
          return com.google.protobuf.Duration.getDefaultInstance();
        } else {
          if (timestampBoundCase_ == 3) {
            return maxStalenessBuilder_.getMessage();
          }
          return com.google.protobuf.Duration.getDefaultInstance();
        }
      }
      /**
       *
       *
       * <pre>
       * Read data at a timestamp &gt;= `NOW - max_staleness`
       * seconds. Guarantees that all writes that have committed more
       * than the specified number of seconds ago are visible. Because
       * Cloud Spanner chooses the exact timestamp, this mode works even if
       * the client's local clock is substantially skewed from Cloud Spanner
       * commit timestamps.
       * Useful for reading the freshest data available at a nearby
       * replica, while bounding the possible staleness if the local
       * replica has fallen behind.
       * Note that this option can only be used in single-use
       * transactions.
       * </pre>
       *
       * <code>.google.protobuf.Duration max_staleness = 3;</code>
       */
      public Builder setMaxStaleness(com.google.protobuf.Duration value) {
        if (maxStalenessBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          timestampBound_ = value;
          onChanged();
        } else {
          maxStalenessBuilder_.setMessage(value);
        }
        timestampBoundCase_ = 3;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Read data at a timestamp &gt;= `NOW - max_staleness`
       * seconds. Guarantees that all writes that have committed more
       * than the specified number of seconds ago are visible. Because
       * Cloud Spanner chooses the exact timestamp, this mode works even if
       * the client's local clock is substantially skewed from Cloud Spanner
       * commit timestamps.
       * Useful for reading the freshest data available at a nearby
       * replica, while bounding the possible staleness if the local
       * replica has fallen behind.
       * Note that this option can only be used in single-use
       * transactions.
       * </pre>
       *
       * <code>.google.protobuf.Duration max_staleness = 3;</code>
       */
      public Builder setMaxStaleness(com.google.protobuf.Duration.Builder builderForValue) {
        if (maxStalenessBuilder_ == null) {
          timestampBound_ = builderForValue.build();
          onChanged();
        } else {
          maxStalenessBuilder_.setMessage(builderForValue.build());
        }
        timestampBoundCase_ = 3;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Read data at a timestamp &gt;= `NOW - max_staleness`
       * seconds. Guarantees that all writes that have committed more
       * than the specified number of seconds ago are visible. Because
       * Cloud Spanner chooses the exact timestamp, this mode works even if
       * the client's local clock is substantially skewed from Cloud Spanner
       * commit timestamps.
       * Useful for reading the freshest data available at a nearby
       * replica, while bounding the possible staleness if the local
       * replica has fallen behind.
       * Note that this option can only be used in single-use
       * transactions.
       * </pre>
       *
       * <code>.google.protobuf.Duration max_staleness = 3;</code>
       */
      public Builder mergeMaxStaleness(com.google.protobuf.Duration value) {
        if (maxStalenessBuilder_ == null) {
          if (timestampBoundCase_ == 3
              && timestampBound_ != com.google.protobuf.Duration.getDefaultInstance()) {
            timestampBound_ =
                com.google.protobuf.Duration.newBuilder(
                        (com.google.protobuf.Duration) timestampBound_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            timestampBound_ = value;
          }
          onChanged();
        } else {
          if (timestampBoundCase_ == 3) {
            maxStalenessBuilder_.mergeFrom(value);
          }
          maxStalenessBuilder_.setMessage(value);
        }
        timestampBoundCase_ = 3;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Read data at a timestamp &gt;= `NOW - max_staleness`
       * seconds. Guarantees that all writes that have committed more
       * than the specified number of seconds ago are visible. Because
       * Cloud Spanner chooses the exact timestamp, this mode works even if
       * the client's local clock is substantially skewed from Cloud Spanner
       * commit timestamps.
       * Useful for reading the freshest data available at a nearby
       * replica, while bounding the possible staleness if the local
       * replica has fallen behind.
       * Note that this option can only be used in single-use
       * transactions.
       * </pre>
       *
       * <code>.google.protobuf.Duration max_staleness = 3;</code>
       */
      public Builder clearMaxStaleness() {
        if (maxStalenessBuilder_ == null) {
          if (timestampBoundCase_ == 3) {
            timestampBoundCase_ = 0;
            timestampBound_ = null;
            onChanged();
          }
        } else {
          if (timestampBoundCase_ == 3) {
            timestampBoundCase_ = 0;
            timestampBound_ = null;
          }
          maxStalenessBuilder_.clear();
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Read data at a timestamp &gt;= `NOW - max_staleness`
       * seconds. Guarantees that all writes that have committed more
       * than the specified number of seconds ago are visible. Because
       * Cloud Spanner chooses the exact timestamp, this mode works even if
       * the client's local clock is substantially skewed from Cloud Spanner
       * commit timestamps.
       * Useful for reading the freshest data available at a nearby
       * replica, while bounding the possible staleness if the local
       * replica has fallen behind.
       * Note that this option can only be used in single-use
       * transactions.
       * </pre>
       *
       * <code>.google.protobuf.Duration max_staleness = 3;</code>
       */
      public com.google.protobuf.Duration.Builder getMaxStalenessBuilder() {
        return getMaxStalenessFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * Read data at a timestamp &gt;= `NOW - max_staleness`
       * seconds. Guarantees that all writes that have committed more
       * than the specified number of seconds ago are visible. Because
       * Cloud Spanner chooses the exact timestamp, this mode works even if
       * the client's local clock is substantially skewed from Cloud Spanner
       * commit timestamps.
       * Useful for reading the freshest data available at a nearby
       * replica, while bounding the possible staleness if the local
       * replica has fallen behind.
       * Note that this option can only be used in single-use
       * transactions.
       * </pre>
       *
       * <code>.google.protobuf.Duration max_staleness = 3;</code>
       */
      @Override
      public com.google.protobuf.DurationOrBuilder getMaxStalenessOrBuilder() {
        if ((timestampBoundCase_ == 3) && (maxStalenessBuilder_ != null)) {
          return maxStalenessBuilder_.getMessageOrBuilder();
        } else {
          if (timestampBoundCase_ == 3) {
            return (com.google.protobuf.Duration) timestampBound_;
          }
          return com.google.protobuf.Duration.getDefaultInstance();
        }
      }
      /**
       *
       *
       * <pre>
       * Read data at a timestamp &gt;= `NOW - max_staleness`
       * seconds. Guarantees that all writes that have committed more
       * than the specified number of seconds ago are visible. Because
       * Cloud Spanner chooses the exact timestamp, this mode works even if
       * the client's local clock is substantially skewed from Cloud Spanner
       * commit timestamps.
       * Useful for reading the freshest data available at a nearby
       * replica, while bounding the possible staleness if the local
       * replica has fallen behind.
       * Note that this option can only be used in single-use
       * transactions.
       * </pre>
       *
       * <code>.google.protobuf.Duration max_staleness = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.Duration,
              com.google.protobuf.Duration.Builder,
              com.google.protobuf.DurationOrBuilder>
          getMaxStalenessFieldBuilder() {
        if (maxStalenessBuilder_ == null) {
          if (!(timestampBoundCase_ == 3)) {
            timestampBound_ = com.google.protobuf.Duration.getDefaultInstance();
          }
          maxStalenessBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  com.google.protobuf.Duration,
                  com.google.protobuf.Duration.Builder,
                  com.google.protobuf.DurationOrBuilder>(
                  (com.google.protobuf.Duration) timestampBound_,
                  getParentForChildren(),
                  isClean());
          timestampBound_ = null;
        }
        timestampBoundCase_ = 3;
        onChanged();
        ;
        return maxStalenessBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.Timestamp,
              com.google.protobuf.Timestamp.Builder,
              com.google.protobuf.TimestampOrBuilder>
          readTimestampBuilder_;
      /**
       *
       *
       * <pre>
       * Executes all reads at the given timestamp. Unlike other modes,
       * reads at a specific timestamp are repeatable; the same read at
       * the same timestamp always returns the same data. If the
       * timestamp is in the future, the read will block until the
       * specified timestamp, modulo the read's deadline.
       * Useful for large scale consistent reads such as mapreduces, or
       * for coordinating many reads against a consistent snapshot of the
       * data.
       * A timestamp in RFC3339 UTC &#92;"Zulu&#92;" format, accurate to nanoseconds.
       * Example: `"2014-10-02T15:01:23.045123456Z"`.
       * </pre>
       *
       * <code>.google.protobuf.Timestamp read_timestamp = 4;</code>
       *
       * @return Whether the readTimestamp field is set.
       */
      @Override
      public boolean hasReadTimestamp() {
        return timestampBoundCase_ == 4;
      }
      /**
       *
       *
       * <pre>
       * Executes all reads at the given timestamp. Unlike other modes,
       * reads at a specific timestamp are repeatable; the same read at
       * the same timestamp always returns the same data. If the
       * timestamp is in the future, the read will block until the
       * specified timestamp, modulo the read's deadline.
       * Useful for large scale consistent reads such as mapreduces, or
       * for coordinating many reads against a consistent snapshot of the
       * data.
       * A timestamp in RFC3339 UTC &#92;"Zulu&#92;" format, accurate to nanoseconds.
       * Example: `"2014-10-02T15:01:23.045123456Z"`.
       * </pre>
       *
       * <code>.google.protobuf.Timestamp read_timestamp = 4;</code>
       *
       * @return The readTimestamp.
       */
      @Override
      public com.google.protobuf.Timestamp getReadTimestamp() {
        if (readTimestampBuilder_ == null) {
          if (timestampBoundCase_ == 4) {
            return (com.google.protobuf.Timestamp) timestampBound_;
          }
          return com.google.protobuf.Timestamp.getDefaultInstance();
        } else {
          if (timestampBoundCase_ == 4) {
            return readTimestampBuilder_.getMessage();
          }
          return com.google.protobuf.Timestamp.getDefaultInstance();
        }
      }
      /**
       *
       *
       * <pre>
       * Executes all reads at the given timestamp. Unlike other modes,
       * reads at a specific timestamp are repeatable; the same read at
       * the same timestamp always returns the same data. If the
       * timestamp is in the future, the read will block until the
       * specified timestamp, modulo the read's deadline.
       * Useful for large scale consistent reads such as mapreduces, or
       * for coordinating many reads against a consistent snapshot of the
       * data.
       * A timestamp in RFC3339 UTC &#92;"Zulu&#92;" format, accurate to nanoseconds.
       * Example: `"2014-10-02T15:01:23.045123456Z"`.
       * </pre>
       *
       * <code>.google.protobuf.Timestamp read_timestamp = 4;</code>
       */
      public Builder setReadTimestamp(com.google.protobuf.Timestamp value) {
        if (readTimestampBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          timestampBound_ = value;
          onChanged();
        } else {
          readTimestampBuilder_.setMessage(value);
        }
        timestampBoundCase_ = 4;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Executes all reads at the given timestamp. Unlike other modes,
       * reads at a specific timestamp are repeatable; the same read at
       * the same timestamp always returns the same data. If the
       * timestamp is in the future, the read will block until the
       * specified timestamp, modulo the read's deadline.
       * Useful for large scale consistent reads such as mapreduces, or
       * for coordinating many reads against a consistent snapshot of the
       * data.
       * A timestamp in RFC3339 UTC &#92;"Zulu&#92;" format, accurate to nanoseconds.
       * Example: `"2014-10-02T15:01:23.045123456Z"`.
       * </pre>
       *
       * <code>.google.protobuf.Timestamp read_timestamp = 4;</code>
       */
      public Builder setReadTimestamp(com.google.protobuf.Timestamp.Builder builderForValue) {
        if (readTimestampBuilder_ == null) {
          timestampBound_ = builderForValue.build();
          onChanged();
        } else {
          readTimestampBuilder_.setMessage(builderForValue.build());
        }
        timestampBoundCase_ = 4;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Executes all reads at the given timestamp. Unlike other modes,
       * reads at a specific timestamp are repeatable; the same read at
       * the same timestamp always returns the same data. If the
       * timestamp is in the future, the read will block until the
       * specified timestamp, modulo the read's deadline.
       * Useful for large scale consistent reads such as mapreduces, or
       * for coordinating many reads against a consistent snapshot of the
       * data.
       * A timestamp in RFC3339 UTC &#92;"Zulu&#92;" format, accurate to nanoseconds.
       * Example: `"2014-10-02T15:01:23.045123456Z"`.
       * </pre>
       *
       * <code>.google.protobuf.Timestamp read_timestamp = 4;</code>
       */
      public Builder mergeReadTimestamp(com.google.protobuf.Timestamp value) {
        if (readTimestampBuilder_ == null) {
          if (timestampBoundCase_ == 4
              && timestampBound_ != com.google.protobuf.Timestamp.getDefaultInstance()) {
            timestampBound_ =
                com.google.protobuf.Timestamp.newBuilder(
                        (com.google.protobuf.Timestamp) timestampBound_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            timestampBound_ = value;
          }
          onChanged();
        } else {
          if (timestampBoundCase_ == 4) {
            readTimestampBuilder_.mergeFrom(value);
          }
          readTimestampBuilder_.setMessage(value);
        }
        timestampBoundCase_ = 4;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Executes all reads at the given timestamp. Unlike other modes,
       * reads at a specific timestamp are repeatable; the same read at
       * the same timestamp always returns the same data. If the
       * timestamp is in the future, the read will block until the
       * specified timestamp, modulo the read's deadline.
       * Useful for large scale consistent reads such as mapreduces, or
       * for coordinating many reads against a consistent snapshot of the
       * data.
       * A timestamp in RFC3339 UTC &#92;"Zulu&#92;" format, accurate to nanoseconds.
       * Example: `"2014-10-02T15:01:23.045123456Z"`.
       * </pre>
       *
       * <code>.google.protobuf.Timestamp read_timestamp = 4;</code>
       */
      public Builder clearReadTimestamp() {
        if (readTimestampBuilder_ == null) {
          if (timestampBoundCase_ == 4) {
            timestampBoundCase_ = 0;
            timestampBound_ = null;
            onChanged();
          }
        } else {
          if (timestampBoundCase_ == 4) {
            timestampBoundCase_ = 0;
            timestampBound_ = null;
          }
          readTimestampBuilder_.clear();
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Executes all reads at the given timestamp. Unlike other modes,
       * reads at a specific timestamp are repeatable; the same read at
       * the same timestamp always returns the same data. If the
       * timestamp is in the future, the read will block until the
       * specified timestamp, modulo the read's deadline.
       * Useful for large scale consistent reads such as mapreduces, or
       * for coordinating many reads against a consistent snapshot of the
       * data.
       * A timestamp in RFC3339 UTC &#92;"Zulu&#92;" format, accurate to nanoseconds.
       * Example: `"2014-10-02T15:01:23.045123456Z"`.
       * </pre>
       *
       * <code>.google.protobuf.Timestamp read_timestamp = 4;</code>
       */
      public com.google.protobuf.Timestamp.Builder getReadTimestampBuilder() {
        return getReadTimestampFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * Executes all reads at the given timestamp. Unlike other modes,
       * reads at a specific timestamp are repeatable; the same read at
       * the same timestamp always returns the same data. If the
       * timestamp is in the future, the read will block until the
       * specified timestamp, modulo the read's deadline.
       * Useful for large scale consistent reads such as mapreduces, or
       * for coordinating many reads against a consistent snapshot of the
       * data.
       * A timestamp in RFC3339 UTC &#92;"Zulu&#92;" format, accurate to nanoseconds.
       * Example: `"2014-10-02T15:01:23.045123456Z"`.
       * </pre>
       *
       * <code>.google.protobuf.Timestamp read_timestamp = 4;</code>
       */
      @Override
      public com.google.protobuf.TimestampOrBuilder getReadTimestampOrBuilder() {
        if ((timestampBoundCase_ == 4) && (readTimestampBuilder_ != null)) {
          return readTimestampBuilder_.getMessageOrBuilder();
        } else {
          if (timestampBoundCase_ == 4) {
            return (com.google.protobuf.Timestamp) timestampBound_;
          }
          return com.google.protobuf.Timestamp.getDefaultInstance();
        }
      }
      /**
       *
       *
       * <pre>
       * Executes all reads at the given timestamp. Unlike other modes,
       * reads at a specific timestamp are repeatable; the same read at
       * the same timestamp always returns the same data. If the
       * timestamp is in the future, the read will block until the
       * specified timestamp, modulo the read's deadline.
       * Useful for large scale consistent reads such as mapreduces, or
       * for coordinating many reads against a consistent snapshot of the
       * data.
       * A timestamp in RFC3339 UTC &#92;"Zulu&#92;" format, accurate to nanoseconds.
       * Example: `"2014-10-02T15:01:23.045123456Z"`.
       * </pre>
       *
       * <code>.google.protobuf.Timestamp read_timestamp = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.Timestamp,
              com.google.protobuf.Timestamp.Builder,
              com.google.protobuf.TimestampOrBuilder>
          getReadTimestampFieldBuilder() {
        if (readTimestampBuilder_ == null) {
          if (!(timestampBoundCase_ == 4)) {
            timestampBound_ = com.google.protobuf.Timestamp.getDefaultInstance();
          }
          readTimestampBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  com.google.protobuf.Timestamp,
                  com.google.protobuf.Timestamp.Builder,
                  com.google.protobuf.TimestampOrBuilder>(
                  (com.google.protobuf.Timestamp) timestampBound_,
                  getParentForChildren(),
                  isClean());
          timestampBound_ = null;
        }
        timestampBoundCase_ = 4;
        onChanged();
        ;
        return readTimestampBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.Duration,
              com.google.protobuf.Duration.Builder,
              com.google.protobuf.DurationOrBuilder>
          exactStalenessBuilder_;
      /**
       *
       *
       * <pre>
       * Executes all reads at a timestamp that is `exact_staleness`
       * old. The timestamp is chosen soon after the read is started.
       * Guarantees that all writes that have committed more than the
       * specified number of seconds ago are visible. Because Cloud Spanner
       * chooses the exact timestamp, this mode works even if the client's
       * local clock is substantially skewed from Cloud Spanner commit
       * timestamps.
       * Useful for reading at nearby replicas without the distributed
       * timestamp negotiation overhead of `max_staleness`.
       * </pre>
       *
       * <code>.google.protobuf.Duration exact_staleness = 5;</code>
       *
       * @return Whether the exactStaleness field is set.
       */
      @Override
      public boolean hasExactStaleness() {
        return timestampBoundCase_ == 5;
      }
      /**
       *
       *
       * <pre>
       * Executes all reads at a timestamp that is `exact_staleness`
       * old. The timestamp is chosen soon after the read is started.
       * Guarantees that all writes that have committed more than the
       * specified number of seconds ago are visible. Because Cloud Spanner
       * chooses the exact timestamp, this mode works even if the client's
       * local clock is substantially skewed from Cloud Spanner commit
       * timestamps.
       * Useful for reading at nearby replicas without the distributed
       * timestamp negotiation overhead of `max_staleness`.
       * </pre>
       *
       * <code>.google.protobuf.Duration exact_staleness = 5;</code>
       *
       * @return The exactStaleness.
       */
      @Override
      public com.google.protobuf.Duration getExactStaleness() {
        if (exactStalenessBuilder_ == null) {
          if (timestampBoundCase_ == 5) {
            return (com.google.protobuf.Duration) timestampBound_;
          }
          return com.google.protobuf.Duration.getDefaultInstance();
        } else {
          if (timestampBoundCase_ == 5) {
            return exactStalenessBuilder_.getMessage();
          }
          return com.google.protobuf.Duration.getDefaultInstance();
        }
      }
      /**
       *
       *
       * <pre>
       * Executes all reads at a timestamp that is `exact_staleness`
       * old. The timestamp is chosen soon after the read is started.
       * Guarantees that all writes that have committed more than the
       * specified number of seconds ago are visible. Because Cloud Spanner
       * chooses the exact timestamp, this mode works even if the client's
       * local clock is substantially skewed from Cloud Spanner commit
       * timestamps.
       * Useful for reading at nearby replicas without the distributed
       * timestamp negotiation overhead of `max_staleness`.
       * </pre>
       *
       * <code>.google.protobuf.Duration exact_staleness = 5;</code>
       */
      public Builder setExactStaleness(com.google.protobuf.Duration value) {
        if (exactStalenessBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          timestampBound_ = value;
          onChanged();
        } else {
          exactStalenessBuilder_.setMessage(value);
        }
        timestampBoundCase_ = 5;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Executes all reads at a timestamp that is `exact_staleness`
       * old. The timestamp is chosen soon after the read is started.
       * Guarantees that all writes that have committed more than the
       * specified number of seconds ago are visible. Because Cloud Spanner
       * chooses the exact timestamp, this mode works even if the client's
       * local clock is substantially skewed from Cloud Spanner commit
       * timestamps.
       * Useful for reading at nearby replicas without the distributed
       * timestamp negotiation overhead of `max_staleness`.
       * </pre>
       *
       * <code>.google.protobuf.Duration exact_staleness = 5;</code>
       */
      public Builder setExactStaleness(com.google.protobuf.Duration.Builder builderForValue) {
        if (exactStalenessBuilder_ == null) {
          timestampBound_ = builderForValue.build();
          onChanged();
        } else {
          exactStalenessBuilder_.setMessage(builderForValue.build());
        }
        timestampBoundCase_ = 5;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Executes all reads at a timestamp that is `exact_staleness`
       * old. The timestamp is chosen soon after the read is started.
       * Guarantees that all writes that have committed more than the
       * specified number of seconds ago are visible. Because Cloud Spanner
       * chooses the exact timestamp, this mode works even if the client's
       * local clock is substantially skewed from Cloud Spanner commit
       * timestamps.
       * Useful for reading at nearby replicas without the distributed
       * timestamp negotiation overhead of `max_staleness`.
       * </pre>
       *
       * <code>.google.protobuf.Duration exact_staleness = 5;</code>
       */
      public Builder mergeExactStaleness(com.google.protobuf.Duration value) {
        if (exactStalenessBuilder_ == null) {
          if (timestampBoundCase_ == 5
              && timestampBound_ != com.google.protobuf.Duration.getDefaultInstance()) {
            timestampBound_ =
                com.google.protobuf.Duration.newBuilder(
                        (com.google.protobuf.Duration) timestampBound_)
                    .mergeFrom(value)
                    .buildPartial();
          } else {
            timestampBound_ = value;
          }
          onChanged();
        } else {
          if (timestampBoundCase_ == 5) {
            exactStalenessBuilder_.mergeFrom(value);
          }
          exactStalenessBuilder_.setMessage(value);
        }
        timestampBoundCase_ = 5;
        return this;
      }
      /**
       *
       *
       * <pre>
       * Executes all reads at a timestamp that is `exact_staleness`
       * old. The timestamp is chosen soon after the read is started.
       * Guarantees that all writes that have committed more than the
       * specified number of seconds ago are visible. Because Cloud Spanner
       * chooses the exact timestamp, this mode works even if the client's
       * local clock is substantially skewed from Cloud Spanner commit
       * timestamps.
       * Useful for reading at nearby replicas without the distributed
       * timestamp negotiation overhead of `max_staleness`.
       * </pre>
       *
       * <code>.google.protobuf.Duration exact_staleness = 5;</code>
       */
      public Builder clearExactStaleness() {
        if (exactStalenessBuilder_ == null) {
          if (timestampBoundCase_ == 5) {
            timestampBoundCase_ = 0;
            timestampBound_ = null;
            onChanged();
          }
        } else {
          if (timestampBoundCase_ == 5) {
            timestampBoundCase_ = 0;
            timestampBound_ = null;
          }
          exactStalenessBuilder_.clear();
        }
        return this;
      }
      /**
       *
       *
       * <pre>
       * Executes all reads at a timestamp that is `exact_staleness`
       * old. The timestamp is chosen soon after the read is started.
       * Guarantees that all writes that have committed more than the
       * specified number of seconds ago are visible. Because Cloud Spanner
       * chooses the exact timestamp, this mode works even if the client's
       * local clock is substantially skewed from Cloud Spanner commit
       * timestamps.
       * Useful for reading at nearby replicas without the distributed
       * timestamp negotiation overhead of `max_staleness`.
       * </pre>
       *
       * <code>.google.protobuf.Duration exact_staleness = 5;</code>
       */
      public com.google.protobuf.Duration.Builder getExactStalenessBuilder() {
        return getExactStalenessFieldBuilder().getBuilder();
      }
      /**
       *
       *
       * <pre>
       * Executes all reads at a timestamp that is `exact_staleness`
       * old. The timestamp is chosen soon after the read is started.
       * Guarantees that all writes that have committed more than the
       * specified number of seconds ago are visible. Because Cloud Spanner
       * chooses the exact timestamp, this mode works even if the client's
       * local clock is substantially skewed from Cloud Spanner commit
       * timestamps.
       * Useful for reading at nearby replicas without the distributed
       * timestamp negotiation overhead of `max_staleness`.
       * </pre>
       *
       * <code>.google.protobuf.Duration exact_staleness = 5;</code>
       */
      @Override
      public com.google.protobuf.DurationOrBuilder getExactStalenessOrBuilder() {
        if ((timestampBoundCase_ == 5) && (exactStalenessBuilder_ != null)) {
          return exactStalenessBuilder_.getMessageOrBuilder();
        } else {
          if (timestampBoundCase_ == 5) {
            return (com.google.protobuf.Duration) timestampBound_;
          }
          return com.google.protobuf.Duration.getDefaultInstance();
        }
      }
      /**
       *
       *
       * <pre>
       * Executes all reads at a timestamp that is `exact_staleness`
       * old. The timestamp is chosen soon after the read is started.
       * Guarantees that all writes that have committed more than the
       * specified number of seconds ago are visible. Because Cloud Spanner
       * chooses the exact timestamp, this mode works even if the client's
       * local clock is substantially skewed from Cloud Spanner commit
       * timestamps.
       * Useful for reading at nearby replicas without the distributed
       * timestamp negotiation overhead of `max_staleness`.
       * </pre>
       *
       * <code>.google.protobuf.Duration exact_staleness = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.Duration,
              com.google.protobuf.Duration.Builder,
              com.google.protobuf.DurationOrBuilder>
          getExactStalenessFieldBuilder() {
        if (exactStalenessBuilder_ == null) {
          if (!(timestampBoundCase_ == 5)) {
            timestampBound_ = com.google.protobuf.Duration.getDefaultInstance();
          }
          exactStalenessBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  com.google.protobuf.Duration,
                  com.google.protobuf.Duration.Builder,
                  com.google.protobuf.DurationOrBuilder>(
                  (com.google.protobuf.Duration) timestampBound_,
                  getParentForChildren(),
                  isClean());
          timestampBound_ = null;
        }
        timestampBoundCase_ = 5;
        onChanged();
        ;
        return exactStalenessBuilder_;
      }

      private boolean returnReadTimestamp_;
      /**
       *
       *
       * <pre>
       * If true, the Cloud Spanner-selected read timestamp is included in
       * the [Transaction][google.spanner.v1.Transaction] message that describes the transaction.
       * </pre>
       *
       * <code>bool return_read_timestamp = 6;</code>
       *
       * @return The returnReadTimestamp.
       */
      @Override
      public boolean getReturnReadTimestamp() {
        return returnReadTimestamp_;
      }
      /**
       *
       *
       * <pre>
       * If true, the Cloud Spanner-selected read timestamp is included in
       * the [Transaction][google.spanner.v1.Transaction] message that describes the transaction.
       * </pre>
       *
       * <code>bool return_read_timestamp = 6;</code>
       *
       * @param value The returnReadTimestamp to set.
       * @return This builder for chaining.
       */
      public Builder setReturnReadTimestamp(boolean value) {

        returnReadTimestamp_ = value;
        onChanged();
        return this;
      }
      /**
       *
       *
       * <pre>
       * If true, the Cloud Spanner-selected read timestamp is included in
       * the [Transaction][google.spanner.v1.Transaction] message that describes the transaction.
       * </pre>
       *
       * <code>bool return_read_timestamp = 6;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearReturnReadTimestamp() {

        returnReadTimestamp_ = false;
        onChanged();
        return this;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:google.spanner.v1.TransactionOptions.ReadOnly)
    }

    // @@protoc_insertion_point(class_scope:google.spanner.v1.TransactionOptions.ReadOnly)
    private static final ReadOnly DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new ReadOnly();
    }

    public static ReadOnly getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ReadOnly> PARSER =
        new com.google.protobuf.AbstractParser<ReadOnly>() {
          @Override
          public ReadOnly parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return new ReadOnly(input, extensionRegistry);
          }
        };

    public static com.google.protobuf.Parser<ReadOnly> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<ReadOnly> getParserForType() {
      return PARSER;
    }

    @Override
    public ReadOnly getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  private int modeCase_ = 0;
  private Object mode_;

  public enum ModeCase implements com.google.protobuf.Internal.EnumLite, InternalOneOfEnum {
    READ_WRITE(1),
    PARTITIONED_DML(3),
    READ_ONLY(2),
    MODE_NOT_SET(0);
    private final int value;

    private ModeCase(int value) {
      this.value = value;
    }
    /**
     * @param value The number of the enum to look for.
     * @return The enum associated with the given number.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @Deprecated
    public static ModeCase valueOf(int value) {
      return forNumber(value);
    }

    public static ModeCase forNumber(int value) {
      switch (value) {
        case 1:
          return READ_WRITE;
        case 3:
          return PARTITIONED_DML;
        case 2:
          return READ_ONLY;
        case 0:
          return MODE_NOT_SET;
        default:
          return null;
      }
    }

    public int getNumber() {
      return this.value;
    }
  };

  public ModeCase getModeCase() {
    return ModeCase.forNumber(modeCase_);
  }

  public static final int READ_WRITE_FIELD_NUMBER = 1;
  /**
   *
   *
   * <pre>
   * Transaction may write.
   * Authorization to begin a read-write transaction requires
   * `spanner.databases.beginOrRollbackReadWriteTransaction` permission
   * on the `session` resource.
   * </pre>
   *
   * <code>.google.spanner.v1.TransactionOptions.ReadWrite read_write = 1;</code>
   *
   * @return Whether the readWrite field is set.
   */
  @Override
  public boolean hasReadWrite() {
    return modeCase_ == 1;
  }
  /**
   *
   *
   * <pre>
   * Transaction may write.
   * Authorization to begin a read-write transaction requires
   * `spanner.databases.beginOrRollbackReadWriteTransaction` permission
   * on the `session` resource.
   * </pre>
   *
   * <code>.google.spanner.v1.TransactionOptions.ReadWrite read_write = 1;</code>
   *
   * @return The readWrite.
   */
  @Override
  public ReadWrite getReadWrite() {
    if (modeCase_ == 1) {
      return (ReadWrite) mode_;
    }
    return ReadWrite.getDefaultInstance();
  }
  /**
   *
   *
   * <pre>
   * Transaction may write.
   * Authorization to begin a read-write transaction requires
   * `spanner.databases.beginOrRollbackReadWriteTransaction` permission
   * on the `session` resource.
   * </pre>
   *
   * <code>.google.spanner.v1.TransactionOptions.ReadWrite read_write = 1;</code>
   */
  @Override
  public ReadWriteOrBuilder getReadWriteOrBuilder() {
    if (modeCase_ == 1) {
      return (ReadWrite) mode_;
    }
    return ReadWrite.getDefaultInstance();
  }

  public static final int PARTITIONED_DML_FIELD_NUMBER = 3;
  /**
   *
   *
   * <pre>
   * Partitioned DML transaction.
   * Authorization to begin a Partitioned DML transaction requires
   * `spanner.databases.beginPartitionedDmlTransaction` permission
   * on the `session` resource.
   * </pre>
   *
   * <code>.google.spanner.v1.TransactionOptions.PartitionedDml partitioned_dml = 3;</code>
   *
   * @return Whether the partitionedDml field is set.
   */
  @Override
  public boolean hasPartitionedDml() {
    return modeCase_ == 3;
  }
  /**
   *
   *
   * <pre>
   * Partitioned DML transaction.
   * Authorization to begin a Partitioned DML transaction requires
   * `spanner.databases.beginPartitionedDmlTransaction` permission
   * on the `session` resource.
   * </pre>
   *
   * <code>.google.spanner.v1.TransactionOptions.PartitionedDml partitioned_dml = 3;</code>
   *
   * @return The partitionedDml.
   */
  @Override
  public PartitionedDml getPartitionedDml() {
    if (modeCase_ == 3) {
      return (PartitionedDml) mode_;
    }
    return PartitionedDml.getDefaultInstance();
  }
  /**
   *
   *
   * <pre>
   * Partitioned DML transaction.
   * Authorization to begin a Partitioned DML transaction requires
   * `spanner.databases.beginPartitionedDmlTransaction` permission
   * on the `session` resource.
   * </pre>
   *
   * <code>.google.spanner.v1.TransactionOptions.PartitionedDml partitioned_dml = 3;</code>
   */
  @Override
  public PartitionedDmlOrBuilder getPartitionedDmlOrBuilder() {
    if (modeCase_ == 3) {
      return (PartitionedDml) mode_;
    }
    return PartitionedDml.getDefaultInstance();
  }

  public static final int READ_ONLY_FIELD_NUMBER = 2;
  /**
   *
   *
   * <pre>
   * Transaction will not write.
   * Authorization to begin a read-only transaction requires
   * `spanner.databases.beginReadOnlyTransaction` permission
   * on the `session` resource.
   * </pre>
   *
   * <code>.google.spanner.v1.TransactionOptions.ReadOnly read_only = 2;</code>
   *
   * @return Whether the readOnly field is set.
   */
  @Override
  public boolean hasReadOnly() {
    return modeCase_ == 2;
  }
  /**
   *
   *
   * <pre>
   * Transaction will not write.
   * Authorization to begin a read-only transaction requires
   * `spanner.databases.beginReadOnlyTransaction` permission
   * on the `session` resource.
   * </pre>
   *
   * <code>.google.spanner.v1.TransactionOptions.ReadOnly read_only = 2;</code>
   *
   * @return The readOnly.
   */
  @Override
  public ReadOnly getReadOnly() {
    if (modeCase_ == 2) {
      return (ReadOnly) mode_;
    }
    return ReadOnly.getDefaultInstance();
  }
  /**
   *
   *
   * <pre>
   * Transaction will not write.
   * Authorization to begin a read-only transaction requires
   * `spanner.databases.beginReadOnlyTransaction` permission
   * on the `session` resource.
   * </pre>
   *
   * <code>.google.spanner.v1.TransactionOptions.ReadOnly read_only = 2;</code>
   */
  @Override
  public ReadOnlyOrBuilder getReadOnlyOrBuilder() {
    if (modeCase_ == 2) {
      return (ReadOnly) mode_;
    }
    return ReadOnly.getDefaultInstance();
  }

  private byte memoizedIsInitialized = -1;

  @Override
  public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized == 1) return true;
    if (isInitialized == 0) return false;

    memoizedIsInitialized = 1;
    return true;
  }

  @Override
  public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
    if (modeCase_ == 1) {
      output.writeMessage(1, (ReadWrite) mode_);
    }
    if (modeCase_ == 2) {
      output.writeMessage(2, (ReadOnly) mode_);
    }
    if (modeCase_ == 3) {
      output.writeMessage(3, (PartitionedDml) mode_);
    }
    unknownFields.writeTo(output);
  }

  @Override
  public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1) return size;

    size = 0;
    if (modeCase_ == 1) {
      size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, (ReadWrite) mode_);
    }
    if (modeCase_ == 2) {
      size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, (ReadOnly) mode_);
    }
    if (modeCase_ == 3) {
      size += com.google.protobuf.CodedOutputStream.computeMessageSize(3, (PartitionedDml) mode_);
    }
    size += unknownFields.getSerializedSize();
    memoizedSize = size;
    return size;
  }

  @Override
  public boolean equals(final Object obj) {
    if (obj == this) {
      return true;
    }
    if (!(obj instanceof TransactionOptions)) {
      return super.equals(obj);
    }
    TransactionOptions other = (TransactionOptions) obj;

    if (!getModeCase().equals(other.getModeCase())) return false;
    switch (modeCase_) {
      case 1:
        if (!getReadWrite().equals(other.getReadWrite())) return false;
        break;
      case 3:
        if (!getPartitionedDml().equals(other.getPartitionedDml())) return false;
        break;
      case 2:
        if (!getReadOnly().equals(other.getReadOnly())) return false;
        break;
      case 0:
      default:
    }
    if (!unknownFields.equals(other.unknownFields)) return false;
    return true;
  }

  @Override
  public int hashCode() {
    if (memoizedHashCode != 0) {
      return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptor().hashCode();
    switch (modeCase_) {
      case 1:
        hash = (37 * hash) + READ_WRITE_FIELD_NUMBER;
        hash = (53 * hash) + getReadWrite().hashCode();
        break;
      case 3:
        hash = (37 * hash) + PARTITIONED_DML_FIELD_NUMBER;
        hash = (53 * hash) + getPartitionedDml().hashCode();
        break;
      case 2:
        hash = (37 * hash) + READ_ONLY_FIELD_NUMBER;
        hash = (53 * hash) + getReadOnly().hashCode();
        break;
      case 0:
      default:
    }
    hash = (29 * hash) + unknownFields.hashCode();
    memoizedHashCode = hash;
    return hash;
  }

  public static TransactionOptions parseFrom(java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static TransactionOptions parseFrom(
      java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static TransactionOptions parseFrom(com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static TransactionOptions parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static TransactionOptions parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static TransactionOptions parseFrom(
      byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static TransactionOptions parseFrom(java.io.InputStream input) throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
  }

  public static TransactionOptions parseFrom(
      java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
        PARSER, input, extensionRegistry);
  }

  public static TransactionOptions parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
  }

  public static TransactionOptions parseDelimitedFrom(
      java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
        PARSER, input, extensionRegistry);
  }

  public static TransactionOptions parseFrom(com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
  }

  public static TransactionOptions parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
        PARSER, input, extensionRegistry);
  }

  @Override
  public Builder newBuilderForType() {
    return newBuilder();
  }

  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }

  public static Builder newBuilder(TransactionOptions prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }

  @Override
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
  }

  @Override
  protected Builder newBuilderForType(BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
  }
  /**
   *
   *
   * <pre>
   * # Transactions
   * Each session can have at most one active transaction at a time (note that
   * standalone reads and queries use a transaction internally and do count
   * towards the one transaction limit). After the active transaction is
   * completed, the session can immediately be re-used for the next transaction.
   * It is not necessary to create a new session for each transaction.
   * # Transaction Modes
   * Cloud Spanner supports three transaction modes:
   *   1. Locking read-write. This type of transaction is the only way
   *      to write data into Cloud Spanner. These transactions rely on
   *      pessimistic locking and, if necessary, two-phase commit.
   *      Locking read-write transactions may abort, requiring the
   *      application to retry.
   *   2. Snapshot read-only. This transaction type provides guaranteed
   *      consistency across several reads, but does not allow
   *      writes. Snapshot read-only transactions can be configured to
   *      read at timestamps in the past. Snapshot read-only
   *      transactions do not need to be committed.
   *   3. Partitioned DML. This type of transaction is used to execute
   *      a single Partitioned DML statement. Partitioned DML partitions
   *      the key space and runs the DML statement over each partition
   *      in parallel using separate, internal transactions that commit
   *      independently. Partitioned DML transactions do not need to be
   *      committed.
   * For transactions that only read, snapshot read-only transactions
   * provide simpler semantics and are almost always faster. In
   * particular, read-only transactions do not take locks, so they do
   * not conflict with read-write transactions. As a consequence of not
   * taking locks, they also do not abort, so retry loops are not needed.
   * Transactions may only read/write data in a single database. They
   * may, however, read/write data in different tables within that
   * database.
   * ## Locking Read-Write Transactions
   * Locking transactions may be used to atomically read-modify-write
   * data anywhere in a database. This type of transaction is externally
   * consistent.
   * Clients should attempt to minimize the amount of time a transaction
   * is active. Faster transactions commit with higher probability
   * and cause less contention. Cloud Spanner attempts to keep read locks
   * active as long as the transaction continues to do reads, and the
   * transaction has not been terminated by
   * [Commit][google.spanner.v1.Spanner.Commit] or
   * [Rollback][google.spanner.v1.Spanner.Rollback].  Long periods of
   * inactivity at the client may cause Cloud Spanner to release a
   * transaction's locks and abort it.
   * Conceptually, a read-write transaction consists of zero or more
   * reads or SQL statements followed by
   * [Commit][google.spanner.v1.Spanner.Commit]. At any time before
   * [Commit][google.spanner.v1.Spanner.Commit], the client can send a
   * [Rollback][google.spanner.v1.Spanner.Rollback] request to abort the
   * transaction.
   * ## Semantics
   * Cloud Spanner can commit the transaction if all read locks it acquired
   * are still valid at commit time, and it is able to acquire write
   * locks for all writes. Cloud Spanner can abort the transaction for any
   * reason. If a commit attempt returns `ABORTED`, Cloud Spanner guarantees
   * that the transaction has not modified any user data in Cloud Spanner.
   * Unless the transaction commits, Cloud Spanner makes no guarantees about
   * how long the transaction's locks were held for. It is an error to
   * use Cloud Spanner locks for any sort of mutual exclusion other than
   * between Cloud Spanner transactions themselves.
   * ## Retrying Aborted Transactions
   * When a transaction aborts, the application can choose to retry the
   * whole transaction again. To maximize the chances of successfully
   * committing the retry, the client should execute the retry in the
   * same session as the original attempt. The original session's lock
   * priority increases with each consecutive abort, meaning that each
   * attempt has a slightly better chance of success than the previous.
   * Under some circumstances (e.g., many transactions attempting to
   * modify the same row(s)), a transaction can abort many times in a
   * short period before successfully committing. Thus, it is not a good
   * idea to cap the number of retries a transaction can attempt;
   * instead, it is better to limit the total amount of wall time spent
   * retrying.
   * ## Idle Transactions
   * A transaction is considered idle if it has no outstanding reads or
   * SQL queries and has not started a read or SQL query within the last 10
   * seconds. Idle transactions can be aborted by Cloud Spanner so that they
   * don't hold on to locks indefinitely. In that case, the commit will
   * fail with error `ABORTED`.
   * If this behavior is undesirable, periodically executing a simple
   * SQL query in the transaction (e.g., `SELECT 1`) prevents the
   * transaction from becoming idle.
   * ## Snapshot Read-Only Transactions
   * Snapshot read-only transactions provides a simpler method than
   * locking read-write transactions for doing several consistent
   * reads. However, this type of transaction does not support writes.
   * Snapshot transactions do not take locks. Instead, they work by
   * choosing a Cloud Spanner timestamp, then executing all reads at that
   * timestamp. Since they do not acquire locks, they do not block
   * concurrent read-write transactions.
   * Unlike locking read-write transactions, snapshot read-only
   * transactions never abort. They can fail if the chosen read
   * timestamp is garbage collected; however, the default garbage
   * collection policy is generous enough that most applications do not
   * need to worry about this in practice.
   * Snapshot read-only transactions do not need to call
   * [Commit][google.spanner.v1.Spanner.Commit] or
   * [Rollback][google.spanner.v1.Spanner.Rollback] (and in fact are not
   * permitted to do so).
   * To execute a snapshot transaction, the client specifies a timestamp
   * bound, which tells Cloud Spanner how to choose a read timestamp.
   * The types of timestamp bound are:
   *   - Strong (the default).
   *   - Bounded staleness.
   *   - Exact staleness.
   * If the Cloud Spanner database to be read is geographically distributed,
   * stale read-only transactions can execute more quickly than strong
   * or read-write transaction, because they are able to execute far
   * from the leader replica.
   * Each type of timestamp bound is discussed in detail below.
   * ## Strong
   * Strong reads are guaranteed to see the effects of all transactions
   * that have committed before the start of the read. Furthermore, all
   * rows yielded by a single read are consistent with each other -- if
   * any part of the read observes a transaction, all parts of the read
   * see the transaction.
   * Strong reads are not repeatable: two consecutive strong read-only
   * transactions might return inconsistent results if there are
   * concurrent writes. If consistency across reads is required, the
   * reads should be executed within a transaction or at an exact read
   * timestamp.
   * See [TransactionOptions.ReadOnly.strong][google.spanner.v1.TransactionOptions.ReadOnly.strong].
   * ## Exact Staleness
   * These timestamp bounds execute reads at a user-specified
   * timestamp. Reads at a timestamp are guaranteed to see a consistent
   * prefix of the global transaction history: they observe
   * modifications done by all transactions with a commit timestamp &lt;=
   * the read timestamp, and observe none of the modifications done by
   * transactions with a larger commit timestamp. They will block until
   * all conflicting transactions that may be assigned commit timestamps
   * &lt;= the read timestamp have finished.
   * The timestamp can either be expressed as an absolute Cloud Spanner commit
   * timestamp or a staleness relative to the current time.
   * These modes do not require a "negotiation phase" to pick a
   * timestamp. As a result, they execute slightly faster than the
   * equivalent boundedly stale concurrency modes. On the other hand,
   * boundedly stale reads usually return fresher results.
   * See [TransactionOptions.ReadOnly.read_timestamp][google.spanner.v1.TransactionOptions.ReadOnly.read_timestamp] and
   * [TransactionOptions.ReadOnly.exact_staleness][google.spanner.v1.TransactionOptions.ReadOnly.exact_staleness].
   * ## Bounded Staleness
   * Bounded staleness modes allow Cloud Spanner to pick the read timestamp,
   * subject to a user-provided staleness bound. Cloud Spanner chooses the
   * newest timestamp within the staleness bound that allows execution
   * of the reads at the closest available replica without blocking.
   * All rows yielded are consistent with each other -- if any part of
   * the read observes a transaction, all parts of the read see the
   * transaction. Boundedly stale reads are not repeatable: two stale
   * reads, even if they use the same staleness bound, can execute at
   * different timestamps and thus return inconsistent results.
   * Boundedly stale reads execute in two phases: the first phase
   * negotiates a timestamp among all replicas needed to serve the
   * read. In the second phase, reads are executed at the negotiated
   * timestamp.
   * As a result of the two phase execution, bounded staleness reads are
   * usually a little slower than comparable exact staleness
   * reads. However, they are typically able to return fresher
   * results, and are more likely to execute at the closest replica.
   * Because the timestamp negotiation requires up-front knowledge of
   * which rows will be read, it can only be used with single-use
   * read-only transactions.
   * See [TransactionOptions.ReadOnly.max_staleness][google.spanner.v1.TransactionOptions.ReadOnly.max_staleness] and
   * [TransactionOptions.ReadOnly.min_read_timestamp][google.spanner.v1.TransactionOptions.ReadOnly.min_read_timestamp].
   * ## Old Read Timestamps and Garbage Collection
   * Cloud Spanner continuously garbage collects deleted and overwritten data
   * in the background to reclaim storage space. This process is known
   * as "version GC". By default, version GC reclaims versions after they
   * are one hour old. Because of this, Cloud Spanner cannot perform reads
   * at read timestamps more than one hour in the past. This
   * restriction also applies to in-progress reads and/or SQL queries whose
   * timestamp become too old while executing. Reads and SQL queries with
   * too-old read timestamps fail with the error `FAILED_PRECONDITION`.
   * ## Partitioned DML Transactions
   * Partitioned DML transactions are used to execute DML statements with a
   * different execution strategy that provides different, and often better,
   * scalability properties for large, table-wide operations than DML in a
   * ReadWrite transaction. Smaller scoped statements, such as an OLTP workload,
   * should prefer using ReadWrite transactions.
   * Partitioned DML partitions the keyspace and runs the DML statement on each
   * partition in separate, internal transactions. These transactions commit
   * automatically when complete, and run independently from one another.
   * To reduce lock contention, this execution strategy only acquires read locks
   * on rows that match the WHERE clause of the statement. Additionally, the
   * smaller per-partition transactions hold locks for less time.
   * That said, Partitioned DML is not a drop-in replacement for standard DML used
   * in ReadWrite transactions.
   *  - The DML statement must be fully-partitionable. Specifically, the statement
   *    must be expressible as the union of many statements which each access only
   *    a single row of the table.
   *  - The statement is not applied atomically to all rows of the table. Rather,
   *    the statement is applied atomically to partitions of the table, in
   *    independent transactions. Secondary index rows are updated atomically
   *    with the base table rows.
   *  - Partitioned DML does not guarantee exactly-once execution semantics
   *    against a partition. The statement will be applied at least once to each
   *    partition. It is strongly recommended that the DML statement should be
   *    idempotent to avoid unexpected results. For instance, it is potentially
   *    dangerous to run a statement such as
   *    `UPDATE table SET column = column + 1` as it could be run multiple times
   *    against some rows.
   *  - The partitions are committed automatically - there is no support for
   *    Commit or Rollback. If the call returns an error, or if the client issuing
   *    the ExecuteSql call dies, it is possible that some rows had the statement
   *    executed on them successfully. It is also possible that statement was
   *    never executed against other rows.
   *  - Partitioned DML transactions may only contain the execution of a single
   *    DML statement via ExecuteSql or ExecuteStreamingSql.
   *  - If any error is encountered during the execution of the partitioned DML
   *    operation (for instance, a UNIQUE INDEX violation, division by zero, or a
   *    value that cannot be stored due to schema constraints), then the
   *    operation is stopped at that point and an error is returned. It is
   *    possible that at this point, some partitions have been committed (or even
   *    committed multiple times), and other partitions have not been run at all.
   * Given the above, Partitioned DML is good fit for large, database-wide,
   * operations that are idempotent, such as deleting old rows from a very large
   * table.
   * </pre>
   *
   * Protobuf type {@code google.spanner.v1.TransactionOptions}
   */
  public static final class Builder extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
      implements
      // @@protoc_insertion_point(builder_implements:google.spanner.v1.TransactionOptions)
      TransactionOptionsOrBuilder {
    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return TransactionProto.internal_static_google_spanner_v1_TransactionOptions_descriptor;
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return TransactionProto
          .internal_static_google_spanner_v1_TransactionOptions_fieldAccessorTable
          .ensureFieldAccessorsInitialized(TransactionOptions.class, Builder.class);
    }

    // Construct using com.google.spanner.v1.TransactionOptions.newBuilder()
    private Builder() {
      maybeForceBuilderInitialization();
    }

    private Builder(BuilderParent parent) {
      super(parent);
      maybeForceBuilderInitialization();
    }

    private void maybeForceBuilderInitialization() {
      if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {}
    }

    @Override
    public Builder clear() {
      super.clear();
      modeCase_ = 0;
      mode_ = null;
      return this;
    }

    @Override
    public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
      return TransactionProto.internal_static_google_spanner_v1_TransactionOptions_descriptor;
    }

    @Override
    public TransactionOptions getDefaultInstanceForType() {
      return TransactionOptions.getDefaultInstance();
    }

    @Override
    public TransactionOptions build() {
      TransactionOptions result = buildPartial();
      if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
      }
      return result;
    }

    @Override
    public TransactionOptions buildPartial() {
      TransactionOptions result = new TransactionOptions(this);
      if (modeCase_ == 1) {
        if (readWriteBuilder_ == null) {
          result.mode_ = mode_;
        } else {
          result.mode_ = readWriteBuilder_.build();
        }
      }
      if (modeCase_ == 3) {
        if (partitionedDmlBuilder_ == null) {
          result.mode_ = mode_;
        } else {
          result.mode_ = partitionedDmlBuilder_.build();
        }
      }
      if (modeCase_ == 2) {
        if (readOnlyBuilder_ == null) {
          result.mode_ = mode_;
        } else {
          result.mode_ = readOnlyBuilder_.build();
        }
      }
      result.modeCase_ = modeCase_;
      onBuilt();
      return result;
    }

    @Override
    public Builder clone() {
      return super.clone();
    }

    @Override
    public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
      return super.setField(field, value);
    }

    @Override
    public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
      return super.clearField(field);
    }

    @Override
    public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
      return super.clearOneof(oneof);
    }

    @Override
    public Builder setRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
      return super.setRepeatedField(field, index, value);
    }

    @Override
    public Builder addRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
      return super.addRepeatedField(field, value);
    }

    @Override
    public Builder mergeFrom(com.google.protobuf.Message other) {
      if (other instanceof TransactionOptions) {
        return mergeFrom((TransactionOptions) other);
      } else {
        super.mergeFrom(other);
        return this;
      }
    }

    public Builder mergeFrom(TransactionOptions other) {
      if (other == TransactionOptions.getDefaultInstance()) return this;
      switch (other.getModeCase()) {
        case READ_WRITE:
          {
            mergeReadWrite(other.getReadWrite());
            break;
          }
        case PARTITIONED_DML:
          {
            mergePartitionedDml(other.getPartitionedDml());
            break;
          }
        case READ_ONLY:
          {
            mergeReadOnly(other.getReadOnly());
            break;
          }
        case MODE_NOT_SET:
          {
            break;
          }
      }
      this.mergeUnknownFields(other.unknownFields);
      onChanged();
      return this;
    }

    @Override
    public final boolean isInitialized() {
      return true;
    }

    @Override
    public Builder mergeFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      TransactionOptions parsedMessage = null;
      try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (TransactionOptions) e.getUnfinishedMessage();
        throw e.unwrapIOException();
      } finally {
        if (parsedMessage != null) {
          mergeFrom(parsedMessage);
        }
      }
      return this;
    }

    private int modeCase_ = 0;
    private Object mode_;

    public ModeCase getModeCase() {
      return ModeCase.forNumber(modeCase_);
    }

    public Builder clearMode() {
      modeCase_ = 0;
      mode_ = null;
      onChanged();
      return this;
    }

    private com.google.protobuf.SingleFieldBuilderV3<
            ReadWrite, ReadWrite.Builder, ReadWriteOrBuilder>
        readWriteBuilder_;
    /**
     *
     *
     * <pre>
     * Transaction may write.
     * Authorization to begin a read-write transaction requires
     * `spanner.databases.beginOrRollbackReadWriteTransaction` permission
     * on the `session` resource.
     * </pre>
     *
     * <code>.google.spanner.v1.TransactionOptions.ReadWrite read_write = 1;</code>
     *
     * @return Whether the readWrite field is set.
     */
    @Override
    public boolean hasReadWrite() {
      return modeCase_ == 1;
    }
    /**
     *
     *
     * <pre>
     * Transaction may write.
     * Authorization to begin a read-write transaction requires
     * `spanner.databases.beginOrRollbackReadWriteTransaction` permission
     * on the `session` resource.
     * </pre>
     *
     * <code>.google.spanner.v1.TransactionOptions.ReadWrite read_write = 1;</code>
     *
     * @return The readWrite.
     */
    @Override
    public ReadWrite getReadWrite() {
      if (readWriteBuilder_ == null) {
        if (modeCase_ == 1) {
          return (ReadWrite) mode_;
        }
        return ReadWrite.getDefaultInstance();
      } else {
        if (modeCase_ == 1) {
          return readWriteBuilder_.getMessage();
        }
        return ReadWrite.getDefaultInstance();
      }
    }
    /**
     *
     *
     * <pre>
     * Transaction may write.
     * Authorization to begin a read-write transaction requires
     * `spanner.databases.beginOrRollbackReadWriteTransaction` permission
     * on the `session` resource.
     * </pre>
     *
     * <code>.google.spanner.v1.TransactionOptions.ReadWrite read_write = 1;</code>
     */
    public Builder setReadWrite(ReadWrite value) {
      if (readWriteBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        mode_ = value;
        onChanged();
      } else {
        readWriteBuilder_.setMessage(value);
      }
      modeCase_ = 1;
      return this;
    }
    /**
     *
     *
     * <pre>
     * Transaction may write.
     * Authorization to begin a read-write transaction requires
     * `spanner.databases.beginOrRollbackReadWriteTransaction` permission
     * on the `session` resource.
     * </pre>
     *
     * <code>.google.spanner.v1.TransactionOptions.ReadWrite read_write = 1;</code>
     */
    public Builder setReadWrite(ReadWrite.Builder builderForValue) {
      if (readWriteBuilder_ == null) {
        mode_ = builderForValue.build();
        onChanged();
      } else {
        readWriteBuilder_.setMessage(builderForValue.build());
      }
      modeCase_ = 1;
      return this;
    }
    /**
     *
     *
     * <pre>
     * Transaction may write.
     * Authorization to begin a read-write transaction requires
     * `spanner.databases.beginOrRollbackReadWriteTransaction` permission
     * on the `session` resource.
     * </pre>
     *
     * <code>.google.spanner.v1.TransactionOptions.ReadWrite read_write = 1;</code>
     */
    public Builder mergeReadWrite(ReadWrite value) {
      if (readWriteBuilder_ == null) {
        if (modeCase_ == 1 && mode_ != ReadWrite.getDefaultInstance()) {
          mode_ = ReadWrite.newBuilder((ReadWrite) mode_).mergeFrom(value).buildPartial();
        } else {
          mode_ = value;
        }
        onChanged();
      } else {
        if (modeCase_ == 1) {
          readWriteBuilder_.mergeFrom(value);
        }
        readWriteBuilder_.setMessage(value);
      }
      modeCase_ = 1;
      return this;
    }
    /**
     *
     *
     * <pre>
     * Transaction may write.
     * Authorization to begin a read-write transaction requires
     * `spanner.databases.beginOrRollbackReadWriteTransaction` permission
     * on the `session` resource.
     * </pre>
     *
     * <code>.google.spanner.v1.TransactionOptions.ReadWrite read_write = 1;</code>
     */
    public Builder clearReadWrite() {
      if (readWriteBuilder_ == null) {
        if (modeCase_ == 1) {
          modeCase_ = 0;
          mode_ = null;
          onChanged();
        }
      } else {
        if (modeCase_ == 1) {
          modeCase_ = 0;
          mode_ = null;
        }
        readWriteBuilder_.clear();
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Transaction may write.
     * Authorization to begin a read-write transaction requires
     * `spanner.databases.beginOrRollbackReadWriteTransaction` permission
     * on the `session` resource.
     * </pre>
     *
     * <code>.google.spanner.v1.TransactionOptions.ReadWrite read_write = 1;</code>
     */
    public ReadWrite.Builder getReadWriteBuilder() {
      return getReadWriteFieldBuilder().getBuilder();
    }
    /**
     *
     *
     * <pre>
     * Transaction may write.
     * Authorization to begin a read-write transaction requires
     * `spanner.databases.beginOrRollbackReadWriteTransaction` permission
     * on the `session` resource.
     * </pre>
     *
     * <code>.google.spanner.v1.TransactionOptions.ReadWrite read_write = 1;</code>
     */
    @Override
    public ReadWriteOrBuilder getReadWriteOrBuilder() {
      if ((modeCase_ == 1) && (readWriteBuilder_ != null)) {
        return readWriteBuilder_.getMessageOrBuilder();
      } else {
        if (modeCase_ == 1) {
          return (ReadWrite) mode_;
        }
        return ReadWrite.getDefaultInstance();
      }
    }
    /**
     *
     *
     * <pre>
     * Transaction may write.
     * Authorization to begin a read-write transaction requires
     * `spanner.databases.beginOrRollbackReadWriteTransaction` permission
     * on the `session` resource.
     * </pre>
     *
     * <code>.google.spanner.v1.TransactionOptions.ReadWrite read_write = 1;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
            ReadWrite, ReadWrite.Builder, ReadWriteOrBuilder>
        getReadWriteFieldBuilder() {
      if (readWriteBuilder_ == null) {
        if (!(modeCase_ == 1)) {
          mode_ = ReadWrite.getDefaultInstance();
        }
        readWriteBuilder_ =
            new com.google.protobuf.SingleFieldBuilderV3<
                ReadWrite, ReadWrite.Builder, ReadWriteOrBuilder>(
                (ReadWrite) mode_, getParentForChildren(), isClean());
        mode_ = null;
      }
      modeCase_ = 1;
      onChanged();
      ;
      return readWriteBuilder_;
    }

    private com.google.protobuf.SingleFieldBuilderV3<
            PartitionedDml, PartitionedDml.Builder, PartitionedDmlOrBuilder>
        partitionedDmlBuilder_;
    /**
     *
     *
     * <pre>
     * Partitioned DML transaction.
     * Authorization to begin a Partitioned DML transaction requires
     * `spanner.databases.beginPartitionedDmlTransaction` permission
     * on the `session` resource.
     * </pre>
     *
     * <code>.google.spanner.v1.TransactionOptions.PartitionedDml partitioned_dml = 3;</code>
     *
     * @return Whether the partitionedDml field is set.
     */
    @Override
    public boolean hasPartitionedDml() {
      return modeCase_ == 3;
    }
    /**
     *
     *
     * <pre>
     * Partitioned DML transaction.
     * Authorization to begin a Partitioned DML transaction requires
     * `spanner.databases.beginPartitionedDmlTransaction` permission
     * on the `session` resource.
     * </pre>
     *
     * <code>.google.spanner.v1.TransactionOptions.PartitionedDml partitioned_dml = 3;</code>
     *
     * @return The partitionedDml.
     */
    @Override
    public PartitionedDml getPartitionedDml() {
      if (partitionedDmlBuilder_ == null) {
        if (modeCase_ == 3) {
          return (PartitionedDml) mode_;
        }
        return PartitionedDml.getDefaultInstance();
      } else {
        if (modeCase_ == 3) {
          return partitionedDmlBuilder_.getMessage();
        }
        return PartitionedDml.getDefaultInstance();
      }
    }
    /**
     *
     *
     * <pre>
     * Partitioned DML transaction.
     * Authorization to begin a Partitioned DML transaction requires
     * `spanner.databases.beginPartitionedDmlTransaction` permission
     * on the `session` resource.
     * </pre>
     *
     * <code>.google.spanner.v1.TransactionOptions.PartitionedDml partitioned_dml = 3;</code>
     */
    public Builder setPartitionedDml(PartitionedDml value) {
      if (partitionedDmlBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        mode_ = value;
        onChanged();
      } else {
        partitionedDmlBuilder_.setMessage(value);
      }
      modeCase_ = 3;
      return this;
    }
    /**
     *
     *
     * <pre>
     * Partitioned DML transaction.
     * Authorization to begin a Partitioned DML transaction requires
     * `spanner.databases.beginPartitionedDmlTransaction` permission
     * on the `session` resource.
     * </pre>
     *
     * <code>.google.spanner.v1.TransactionOptions.PartitionedDml partitioned_dml = 3;</code>
     */
    public Builder setPartitionedDml(PartitionedDml.Builder builderForValue) {
      if (partitionedDmlBuilder_ == null) {
        mode_ = builderForValue.build();
        onChanged();
      } else {
        partitionedDmlBuilder_.setMessage(builderForValue.build());
      }
      modeCase_ = 3;
      return this;
    }
    /**
     *
     *
     * <pre>
     * Partitioned DML transaction.
     * Authorization to begin a Partitioned DML transaction requires
     * `spanner.databases.beginPartitionedDmlTransaction` permission
     * on the `session` resource.
     * </pre>
     *
     * <code>.google.spanner.v1.TransactionOptions.PartitionedDml partitioned_dml = 3;</code>
     */
    public Builder mergePartitionedDml(PartitionedDml value) {
      if (partitionedDmlBuilder_ == null) {
        if (modeCase_ == 3 && mode_ != PartitionedDml.getDefaultInstance()) {
          mode_ = PartitionedDml.newBuilder((PartitionedDml) mode_).mergeFrom(value).buildPartial();
        } else {
          mode_ = value;
        }
        onChanged();
      } else {
        if (modeCase_ == 3) {
          partitionedDmlBuilder_.mergeFrom(value);
        }
        partitionedDmlBuilder_.setMessage(value);
      }
      modeCase_ = 3;
      return this;
    }
    /**
     *
     *
     * <pre>
     * Partitioned DML transaction.
     * Authorization to begin a Partitioned DML transaction requires
     * `spanner.databases.beginPartitionedDmlTransaction` permission
     * on the `session` resource.
     * </pre>
     *
     * <code>.google.spanner.v1.TransactionOptions.PartitionedDml partitioned_dml = 3;</code>
     */
    public Builder clearPartitionedDml() {
      if (partitionedDmlBuilder_ == null) {
        if (modeCase_ == 3) {
          modeCase_ = 0;
          mode_ = null;
          onChanged();
        }
      } else {
        if (modeCase_ == 3) {
          modeCase_ = 0;
          mode_ = null;
        }
        partitionedDmlBuilder_.clear();
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Partitioned DML transaction.
     * Authorization to begin a Partitioned DML transaction requires
     * `spanner.databases.beginPartitionedDmlTransaction` permission
     * on the `session` resource.
     * </pre>
     *
     * <code>.google.spanner.v1.TransactionOptions.PartitionedDml partitioned_dml = 3;</code>
     */
    public PartitionedDml.Builder getPartitionedDmlBuilder() {
      return getPartitionedDmlFieldBuilder().getBuilder();
    }
    /**
     *
     *
     * <pre>
     * Partitioned DML transaction.
     * Authorization to begin a Partitioned DML transaction requires
     * `spanner.databases.beginPartitionedDmlTransaction` permission
     * on the `session` resource.
     * </pre>
     *
     * <code>.google.spanner.v1.TransactionOptions.PartitionedDml partitioned_dml = 3;</code>
     */
    @Override
    public PartitionedDmlOrBuilder getPartitionedDmlOrBuilder() {
      if ((modeCase_ == 3) && (partitionedDmlBuilder_ != null)) {
        return partitionedDmlBuilder_.getMessageOrBuilder();
      } else {
        if (modeCase_ == 3) {
          return (PartitionedDml) mode_;
        }
        return PartitionedDml.getDefaultInstance();
      }
    }
    /**
     *
     *
     * <pre>
     * Partitioned DML transaction.
     * Authorization to begin a Partitioned DML transaction requires
     * `spanner.databases.beginPartitionedDmlTransaction` permission
     * on the `session` resource.
     * </pre>
     *
     * <code>.google.spanner.v1.TransactionOptions.PartitionedDml partitioned_dml = 3;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
            PartitionedDml, PartitionedDml.Builder, PartitionedDmlOrBuilder>
        getPartitionedDmlFieldBuilder() {
      if (partitionedDmlBuilder_ == null) {
        if (!(modeCase_ == 3)) {
          mode_ = PartitionedDml.getDefaultInstance();
        }
        partitionedDmlBuilder_ =
            new com.google.protobuf.SingleFieldBuilderV3<
                PartitionedDml, PartitionedDml.Builder, PartitionedDmlOrBuilder>(
                (PartitionedDml) mode_, getParentForChildren(), isClean());
        mode_ = null;
      }
      modeCase_ = 3;
      onChanged();
      ;
      return partitionedDmlBuilder_;
    }

    private com.google.protobuf.SingleFieldBuilderV3<ReadOnly, ReadOnly.Builder, ReadOnlyOrBuilder>
        readOnlyBuilder_;
    /**
     *
     *
     * <pre>
     * Transaction will not write.
     * Authorization to begin a read-only transaction requires
     * `spanner.databases.beginReadOnlyTransaction` permission
     * on the `session` resource.
     * </pre>
     *
     * <code>.google.spanner.v1.TransactionOptions.ReadOnly read_only = 2;</code>
     *
     * @return Whether the readOnly field is set.
     */
    @Override
    public boolean hasReadOnly() {
      return modeCase_ == 2;
    }
    /**
     *
     *
     * <pre>
     * Transaction will not write.
     * Authorization to begin a read-only transaction requires
     * `spanner.databases.beginReadOnlyTransaction` permission
     * on the `session` resource.
     * </pre>
     *
     * <code>.google.spanner.v1.TransactionOptions.ReadOnly read_only = 2;</code>
     *
     * @return The readOnly.
     */
    @Override
    public ReadOnly getReadOnly() {
      if (readOnlyBuilder_ == null) {
        if (modeCase_ == 2) {
          return (ReadOnly) mode_;
        }
        return ReadOnly.getDefaultInstance();
      } else {
        if (modeCase_ == 2) {
          return readOnlyBuilder_.getMessage();
        }
        return ReadOnly.getDefaultInstance();
      }
    }
    /**
     *
     *
     * <pre>
     * Transaction will not write.
     * Authorization to begin a read-only transaction requires
     * `spanner.databases.beginReadOnlyTransaction` permission
     * on the `session` resource.
     * </pre>
     *
     * <code>.google.spanner.v1.TransactionOptions.ReadOnly read_only = 2;</code>
     */
    public Builder setReadOnly(ReadOnly value) {
      if (readOnlyBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        mode_ = value;
        onChanged();
      } else {
        readOnlyBuilder_.setMessage(value);
      }
      modeCase_ = 2;
      return this;
    }
    /**
     *
     *
     * <pre>
     * Transaction will not write.
     * Authorization to begin a read-only transaction requires
     * `spanner.databases.beginReadOnlyTransaction` permission
     * on the `session` resource.
     * </pre>
     *
     * <code>.google.spanner.v1.TransactionOptions.ReadOnly read_only = 2;</code>
     */
    public Builder setReadOnly(ReadOnly.Builder builderForValue) {
      if (readOnlyBuilder_ == null) {
        mode_ = builderForValue.build();
        onChanged();
      } else {
        readOnlyBuilder_.setMessage(builderForValue.build());
      }
      modeCase_ = 2;
      return this;
    }
    /**
     *
     *
     * <pre>
     * Transaction will not write.
     * Authorization to begin a read-only transaction requires
     * `spanner.databases.beginReadOnlyTransaction` permission
     * on the `session` resource.
     * </pre>
     *
     * <code>.google.spanner.v1.TransactionOptions.ReadOnly read_only = 2;</code>
     */
    public Builder mergeReadOnly(ReadOnly value) {
      if (readOnlyBuilder_ == null) {
        if (modeCase_ == 2 && mode_ != ReadOnly.getDefaultInstance()) {
          mode_ = ReadOnly.newBuilder((ReadOnly) mode_).mergeFrom(value).buildPartial();
        } else {
          mode_ = value;
        }
        onChanged();
      } else {
        if (modeCase_ == 2) {
          readOnlyBuilder_.mergeFrom(value);
        }
        readOnlyBuilder_.setMessage(value);
      }
      modeCase_ = 2;
      return this;
    }
    /**
     *
     *
     * <pre>
     * Transaction will not write.
     * Authorization to begin a read-only transaction requires
     * `spanner.databases.beginReadOnlyTransaction` permission
     * on the `session` resource.
     * </pre>
     *
     * <code>.google.spanner.v1.TransactionOptions.ReadOnly read_only = 2;</code>
     */
    public Builder clearReadOnly() {
      if (readOnlyBuilder_ == null) {
        if (modeCase_ == 2) {
          modeCase_ = 0;
          mode_ = null;
          onChanged();
        }
      } else {
        if (modeCase_ == 2) {
          modeCase_ = 0;
          mode_ = null;
        }
        readOnlyBuilder_.clear();
      }
      return this;
    }
    /**
     *
     *
     * <pre>
     * Transaction will not write.
     * Authorization to begin a read-only transaction requires
     * `spanner.databases.beginReadOnlyTransaction` permission
     * on the `session` resource.
     * </pre>
     *
     * <code>.google.spanner.v1.TransactionOptions.ReadOnly read_only = 2;</code>
     */
    public ReadOnly.Builder getReadOnlyBuilder() {
      return getReadOnlyFieldBuilder().getBuilder();
    }
    /**
     *
     *
     * <pre>
     * Transaction will not write.
     * Authorization to begin a read-only transaction requires
     * `spanner.databases.beginReadOnlyTransaction` permission
     * on the `session` resource.
     * </pre>
     *
     * <code>.google.spanner.v1.TransactionOptions.ReadOnly read_only = 2;</code>
     */
    @Override
    public ReadOnlyOrBuilder getReadOnlyOrBuilder() {
      if ((modeCase_ == 2) && (readOnlyBuilder_ != null)) {
        return readOnlyBuilder_.getMessageOrBuilder();
      } else {
        if (modeCase_ == 2) {
          return (ReadOnly) mode_;
        }
        return ReadOnly.getDefaultInstance();
      }
    }
    /**
     *
     *
     * <pre>
     * Transaction will not write.
     * Authorization to begin a read-only transaction requires
     * `spanner.databases.beginReadOnlyTransaction` permission
     * on the `session` resource.
     * </pre>
     *
     * <code>.google.spanner.v1.TransactionOptions.ReadOnly read_only = 2;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<ReadOnly, ReadOnly.Builder, ReadOnlyOrBuilder>
        getReadOnlyFieldBuilder() {
      if (readOnlyBuilder_ == null) {
        if (!(modeCase_ == 2)) {
          mode_ = ReadOnly.getDefaultInstance();
        }
        readOnlyBuilder_ =
            new com.google.protobuf.SingleFieldBuilderV3<
                ReadOnly, ReadOnly.Builder, ReadOnlyOrBuilder>(
                (ReadOnly) mode_, getParentForChildren(), isClean());
        mode_ = null;
      }
      modeCase_ = 2;
      onChanged();
      ;
      return readOnlyBuilder_;
    }

    @Override
    public final Builder setUnknownFields(final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.setUnknownFields(unknownFields);
    }

    @Override
    public final Builder mergeUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.mergeUnknownFields(unknownFields);
    }

    // @@protoc_insertion_point(builder_scope:google.spanner.v1.TransactionOptions)
  }

  // @@protoc_insertion_point(class_scope:google.spanner.v1.TransactionOptions)
  private static final TransactionOptions DEFAULT_INSTANCE;

  static {
    DEFAULT_INSTANCE = new TransactionOptions();
  }

  public static TransactionOptions getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static final com.google.protobuf.Parser<TransactionOptions> PARSER =
      new com.google.protobuf.AbstractParser<TransactionOptions>() {
        @Override
        public TransactionOptions parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new TransactionOptions(input, extensionRegistry);
        }
      };

  public static com.google.protobuf.Parser<TransactionOptions> parser() {
    return PARSER;
  }

  @Override
  public com.google.protobuf.Parser<TransactionOptions> getParserForType() {
    return PARSER;
  }

  @Override
  public TransactionOptions getDefaultInstanceForType() {
    return DEFAULT_INSTANCE;
  }
}
